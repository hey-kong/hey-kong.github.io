<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Iggie Wang&#039;s Cyberspace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Iggie Wang&#039;s Cyberspace"><meta name="msapplication-TileImage" content="/img/dog.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Iggie Wang&#039;s Cyberspace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Iggie Wang&#039;s Cyberspace"><meta property="og:url" content="https://hey-kong.github.io/"><meta property="og:site_name" content="Iggie Wang&#039;s Cyberspace"><meta property="og:image" content="https://hey-kong.github.io/img/og_image.png"><meta property="article:author" content="王亮"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hey-kong.github.io"},"headline":"Iggie Wang's Cyberspace","image":["https://hey-kong.github.io/img/og_image.png"],"author":{"@type":"Person","name":"王亮"},"publisher":{"@type":"Organization","name":"Iggie Wang's Cyberspace","logo":{"@type":"ImageObject","url":null}},"description":""}</script><link rel="icon" href="/img/dog.jpg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Iggie Wang&#039;s Cyberspace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Buscar" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2021-10-01T06:46:46.000Z" title="2021/10/1 下午2:46:46">2021-10-01</time></span><span class="level-item">12 minutes de lectura (Aproximadamente 1727 palabras)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/">ALEX: An Updatable Adaptive Learned Index</a></h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ALEX 是一个可更新的内存型学习索引。对比 B+Tree 和 Learned Index，ALEX 的目标是：(1)插入时间与 B+Tree 接近，(2)查找时间应该比 B+Tree 和 Learned Index 快，(3)索引存储空间应该比 B+Tree 和 Learned Index 小，(4)数据存储空间（叶子节点）应该与 B+Tree 相当。</p>
<p>ALEX 的设计如下：</p>
<div align="center">
<img src="/2021/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/1.png" style="zoom:100%;">
</div>

<ul>
<li>ALEX 动态调整 RMI 的形状和高度，节点可以进行扩展和分割</li>
<li>ALEX 使用 Exponential Search 来寻找叶子层的 key，以纠正 RMI 的错误预测，这比 Binary Search 效果更好</li>
<li>ALEX 在数据节点上使用 Gapped Array(GA)，将数据插入在自己预测的地方。这和 RMI 有很大的不同。RMI 是先排好序，让后训练模型去拟合数据。而 ALEX 是在模型拟合完数据后，将数据在按照模型的预测值插入到对应的地方，这大大降低了预测的错误率</li>
<li>ALEX 的 RMI 结构的目标不是产生同等大小的数据节点，而是产生 key 分布大致为线性的数据节点，以便线性模型能够准确地拟合。因此，ALEX 中的内部节点更加灵活。例如下图中节点 A 中 keys 的范围在  [0,1) 内，并有四个指针。ALEX 将 keys 范围 [0,1/4) 和 [1/2,1) 分配给数据节点（因为这些空间的 CDF 是线性的），并将 [1/4,1/2) 分配给另一个内部节点（因为CDF是非线性的，RMI需要对这个空间进行更多的划分）。另外，多个指针可以指向同一个子节点，便于插入；限制每个内部节点的指针数量总是 2 的幂，便于节点可以在不重新训练的情况下分裂</li>
</ul>
<div align="center"><img src="/2021/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/2.png" style="zoom:100%;"></div>

<p>下面介绍 ALEX 的查询、插入、删除等步骤。</p>
<h2 id="Lookups-and-Range-Queries"><a href="#Lookups-and-Range-Queries" class="headerlink" title="Lookups and Range Queries"></a>Lookups and Range Queries</h2><p>查找时，从 RMI 的根节点开始，使用模型计算在哪一个位置，然后迭代地查询下一级的叶子节点，直到到达一个数据节点。在数据节点中使用模型来查询 key 在数组中的位置，如果预测失败，则进行 Exponential Search 以找到 key 的实际位置。如果找到了一个 key，读取对应值并返回记录，否则返回一个空记录。对于范围查询，首先找到第一个 key 的位置，该 key 不小于范围的起始值，然后扫描，直到到达范围的结束值，使用节点的 bitmap 跳过间隙，必要时跳到下一个数据节点。</p>
<h2 id="Insert-in-non-full-Data-Node"><a href="#Insert-in-non-full-Data-Node" class="headerlink" title="Insert in non-full Data Node"></a>Insert in non-full Data Node</h2><p>插入逻辑与上述查找算法相同。在一个 non-full 的数据节点中，使用数据节点中的模型来预测插入位置。如果预测的位置不正确（不能保持有序），则做 Exponential Search 来找到正确的插入位置。如果插入位置为空，则直接插入，否则插入到最近的间隙中。Gapped Array实现了 O(logn) 插入时间。</p>
<h2 id="Insert-in-full-Data-Node"><a href="#Insert-in-full-Data-Node" class="headerlink" title="Insert in full Data Node"></a>Insert in full Data Node</h2><h3 id="Criteria-for-Node-Fullness"><a href="#Criteria-for-Node-Fullness" class="headerlink" title="Criteria for Node Fullness"></a>Criteria for Node Fullness</h3><p>ALEX 并不会让数据节点 100% 充满，因为在 Gapped Array 上的插入性能会随着间隙数量的减少而下降。需要在 Gapped Array 上引入了密度的下限和上限：dl, du ∈ (0, 1)，约束dl &lt; du。密度被定义为被元素填充的位置的百分比。如果下一次插入使得密度超过了 du，那么这个节点就是满的。默认情况下，我们设置 dl=0.6，du=0.8。相比之下，B+Tree 的节点通常有 dl=0.5 和 du=1。</p>
<h3 id="Node-Expansion-Mechanism"><a href="#Node-Expansion-Mechanism" class="headerlink" title="Node Expansion Mechanism"></a>Node Expansion Mechanism</h3><p>扩展一个包含 N 个 key 的数据节点，需要创建一个具有 N/dl 槽的新的较大的 Gapped Array。然后对线性回归模型进行缩放或重新训练，然后使用缩放或重新训练的模型对这个节点中的所有元素进行基于模型的插入。新的数据节点的密度处于下限 dl。下图为一个数据节点扩展的例子，数据节点内的 Gapped Array 从左边的两个槽扩展到右边的四个槽。</p>
<div align="center"><img src="/2021/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/3.png" style="zoom:100%;"></div>

<h3 id="Node-Split-Mechanism"><a href="#Node-Split-Mechanism" class="headerlink" title="Node Split Mechanism"></a>Node Split Mechanism</h3><ol>
<li>水平分裂。有两种情况：(1) 如果待分裂的数据节点的父内部节点还没有达到最大的节点大小，父内部节点的指针数组可能有多余的指向待分裂数据节点的指针。如果有，则各让一半的指针指向两个新数据节点。否则，将父节点的指针数组的大小增加一倍，并为每个指针制作一个冗余的副本，来创建第二个指向分裂数据节点的指针，然后再分裂。下图(a)展示了一个不需要扩展父内部节点的侧向分裂的例子。(2) 如果父内部节点已经达到最大节点大小，那么我们可以选择拆分父内部节点，如下图(b)中所示。因为内部节点的大小为2的幂，所以总是可以拆分一个数据节点，不需要对拆分后的任何模型进行重新训练。分裂可以一直传播到根节点，就像在 B+Tree 中一样。</li>
<li>向下分裂。如下图(c)所示，向下分裂将一个数据节点转换为具有两个子数据节点的内部节点。两个子数据节点中的模型是根据它们各自的 key 来训练的。</li>
</ol>
<div align="center"><img src="/2021/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/4.png" style="zoom:100%;"></div>

<h2 id="Delete-and-update"><a href="#Delete-and-update" class="headerlink" title="Delete and update"></a>Delete and update</h2><p>要删除一个 key，需要先找到该 key 的位置，然后删除它和它对应的值。删除不会移动任何现有的 key，所以删除是一个严格意义上的比插入更简单的操作，不会导致模型的准确性下降。如果一个数据节点由于删除而达到了密度下限 dl，那么就缩小数据节点（与扩大数据节点相反），以避免空间利用率过低。此外还可以使用节点内的成本模型来确定两个数据节点是否应该合并在一起，然而为了简单起见，ALEX 开源代码中并没有实现这些合并操作。<br>key 更新是通过结合插入和删除来实现的；值更新是通过查找 key 并将新值写入来实现的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/uploads/prod/2020/04/MSRAlexTechnicalReportV2.pdf">ALEX: An Updatable Adaptive Learned Index</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2021-09-30T07:54:14.000Z" title="2021/9/30 下午3:54:14">2021-09-30</time></span><span class="level-item">9 minutes de lectura (Aproximadamente 1398 palabras)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/30/gRPC-Introduction/">gRPC Introduction</a></h1><div class="content"><h2 id="gRPC-Overview"><a href="#gRPC-Overview" class="headerlink" title="gRPC Overview"></a>gRPC Overview</h2><p>gRPC is a language-neutral RPC framework developed and open-sourced by Google, currently supporting C, Java, and Go languages. The C version supports languages such as C, C++, Node.js, C#. In gRPC, client applications can directly call methods on a server on a different machine as if they were calling local methods.</p>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/1.png" style="zoom:100%;">
</div>

<p>The simple steps to use gRPC are as follows, taking Go language as an example:</p>
<ol>
<li>Write the proto file and use protoc to generate the .pb.go file.</li>
<li>On the server side, define a Server, create a Function to implement the interface -&gt; net.Listen -&gt; grpc.NewServer() -&gt; pb.RegisterXXXServer(server, &amp;Server{}) -&gt; server.Serve(listener).</li>
<li>On the client side, grpc.Dial to create a gRPC connection -&gt; pb.NewXXXClient(conn) to create a client -&gt; context.WithTimeout to set a timeout -&gt; call the interface with client.Function -&gt; If it is stream transmission, loop to read data.</li>
</ol>
<h2 id="gRPC-Concepts"><a href="#gRPC-Concepts" class="headerlink" title="gRPC Concepts"></a>gRPC Concepts</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/2.png" style="zoom:100%;">
</div>

<h4 id="Unary-RPC"><a href="#Unary-RPC" class="headerlink" title="Unary RPC"></a>Unary RPC</h4><p>The client sends a request to the server and gets a response from the server, just like a normal function call.</p>
<h4 id="Server-streaming-RPC"><a href="#Server-streaming-RPC" class="headerlink" title="Server streaming RPC"></a>Server streaming RPC</h4><p>The client sends a request to the server and can get a data stream to read a series of messages. The client reads from the returned data stream until there are no more messages.<br>The server needs to send messages into the stream, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n :&#x3D; 0; n &lt; 5; n++ &#123;</span><br><span class="line">    err :&#x3D; server.Send(&amp;pb.StreamResponse&#123;</span><br><span class="line">        StreamValue: req.Data + strconv.Itoa(n),</span><br><span class="line">    &#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client gets a stream transmission object ‘stream’ through the grpc call and needs to loop to receive data, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; Determine whether the message stream has ended</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatalf(&quot;ListStr get stream err: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Print the return value</span><br><span class="line">    log.Println(res.StreamValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client-streaming-RPC"><a href="#Client-streaming-RPC" class="headerlink" title="Client streaming RPC"></a>Client streaming RPC</h4><p>The client writes and sends a series of messages to the server using a provided data stream. Once the client finishes writing messages, it waits for the server to read these messages and return a response.</p>
<p>The server uses stream.Recv() to loop to receive the data stream, and SendAndClose indicates that the server has finished receiving messages and sends a correct response to the client, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for  &#123;</span><br><span class="line">    res,err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; Message reception ends, send the result, and close</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return stream.SendAndClose(&amp;proto.UploadResponse&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D;nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client needs to call CloseAndRecv when it has finished sending data, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    img :&#x3D; &amp;proto.Image&#123;FileName:&quot;image&quot;+strconv.Itoa(i),File:&quot;file data&quot;&#125;</span><br><span class="line">    images :&#x3D; &amp;proto.StreamImageList&#123;Image:img&#125;</span><br><span class="line">    err :&#x3D; stream.Send(images)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        ctx.JSON(map[string]string&#123;</span><br><span class="line">            &quot;err&quot;: err.Error(),</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Finish sending, close and get the message returned by the server</span><br><span class="line">resp, err :&#x3D; stream.CloseAndRecv()</span><br></pre></td></tr></table></figure>
<h4 id="Bidirectional-streaming-RPC"><a href="#Bidirectional-streaming-RPC" class="headerlink" title="Bidirectional streaming RPC"></a>Bidirectional streaming RPC</h4><p>Both sides can separately send a series of messages via a read-write data stream. These two streams operate independently, so the client and server can read and write in any order they wish, for example: the server can wait for all client messages before writing a response, or it can read a message then write a message, or use other combinations of reading and writing.</p>
<p>The server sends messages while receiving messages, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamSumData&#123;Number: int32(i)&#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client needs a flag to disconnect, CloseSend(), but the server doesn’t need it because the server disconnects implicitly. We just need to exit the loop to disconnect, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamRequest&#123;&#125;)</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(&quot;res number: %d&quot;, res.Number)</span><br><span class="line">&#125;</span><br><span class="line">stream.CloseSend()</span><br></pre></td></tr></table></figure>
<h3 id="Synchronous"><a href="#Synchronous" class="headerlink" title="Synchronous"></a>Synchronous</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/3.jpg" style="zoom:100%;">
</div>

<p>A Channel provides a connection established with the host and port of a specific gRPC server. A Stub is created based on the Channel, and the RPC request can be actually called through the Stub.</p>
<h3 id="Asynchronous-based-on-CQ"><a href="#Asynchronous-based-on-CQ" class="headerlink" title="Asynchronous based on CQ"></a>Asynchronous based on CQ</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/4.jpg" style="zoom:100%;">
</div>

<ul>
<li>CQ: Notification queue for completed asynchronous operations</li>
<li>StartCall() + Finish(): Create asynchronous tasks</li>
<li>CQ.next(): Get completed asynchronous operations</li>
<li>Tag: Identifiers marking asynchronous actions</li>
</ul>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/5.jpg" style="zoom:100%;">
</div>

<p>Multiple threads can operate on the same CQ. CQ.next() can receive not only the completion events of the current request being processed but also the events of other requests. Suppose the first request is waiting for its reply data transmission to complete, and a new request arrives. CQ.next() can get the events generated by the new request and start processing the new request in parallel without waiting for the first request’s transmission to complete.</p>
<h3 id="Asynchronous-based-on-Callback"><a href="#Asynchronous-based-on-Callback" class="headerlink" title="Asynchronous based on Callback"></a>Asynchronous based on Callback</h3><p>On the client side, send a single request, when calling the Function, in addition to passing the pointers of Request and Reply, a callback function receiving Status is also needed.</p>
<p>On the server side, the Function doesn’t return a status, but a ServerUnaryReactor pointer. Get the reactor through CallbackServerContext and call the Finish function of the reactor to handle the return status.</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><ul>
<li>Transfers some custom Metadata between the client and server.</li>
<li>Similar to HTTP headers, it controls call configurations such as compression, authentication, and timeout.</li>
<li>Assists observability, such as Trace ID.</li>
</ul>
<h2 id="gRPC-Communication-Protocol"><a href="#gRPC-Communication-Protocol" class="headerlink" title="gRPC Communication Protocol"></a>gRPC Communication Protocol</h2><p>The gRPC communication protocol is based on standard HTTP/2 design, supports bidirectional streams, multiplexing of single TCP (an HTTP request can be initiated in advance without waiting for the result of the previous HTTP request, and multiple requests can share the same HTTP connection without interfering with each other) and features such as message header compression and server push. These features make gRPC more power-saving and network traffic-saving on mobile devices.</p>
<h2 id="gRPC-Serialization-Mechanism"><a href="#gRPC-Serialization-Mechanism" class="headerlink" title="gRPC Serialization Mechanism"></a>gRPC Serialization Mechanism</h2><h3 id="Introduction-to-Protocol-Buffers"><a href="#Introduction-to-Protocol-Buffers" class="headerlink" title="Introduction to Protocol Buffers"></a>Introduction to Protocol Buffers</h3><p>gRPC serialization supports Protocol Buffers. ProtoBuf is a lightweight and efficient data structure serialization method, ensuring the high performance of gRPC calls. Its advantages include:</p>
<ul>
<li>The volume of ProtoBuf after serialization is much smaller than JSON, XML, and the speed of serialization/deserialization is faster.</li>
<li>Supports cross-platform and multi-language.</li>
<li>Easy to use because it provides a set of compilation tools that can automatically generate serialization and deserialization boilerplate code.</li>
</ul>
<p>However, ProtoBuf is a binary protocol, the readability of the encoded binary data stream is poor, and debugging is troublesome.</p>
<p>The scalar value types supported by ProtoBuf are as follows:</p>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/type.png" style="zoom:100%;">
</div>

<p>Why is ProtoBuf fast?</p>
<ul>
<li>Because each field is stored continuously in the form of tag+value, the tag is a number, usually only occupying one byte, and the value is the value of the field, so there are no redundant characters.</li>
<li>In addition, for relatively small integers, ProtoBuf defines a Varint variable integer, which does not need to be stored in 4 bytes.</li>
<li>If the value is of string type and the specific length of the value cannot be known from the tag, ProtoBuf will add a leg field between the tag and the value to record the length of the string, so that string matching operations do not need to be performed, and the parsing speed is very fast.</li>
</ul>
<h3 id="Definition-of-IDL-file"><a href="#Definition-of-IDL-file" class="headerlink" title="Definition of IDL file"></a>Definition of IDL file</h3><p>Define the data structure of RPC requests and responses in the proto file according to the syntax of Protocol Buffers, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">option go_package &#x3D; &quot;..&#x2F;helloworld&quot;;</span><br><span class="line">package helloworld;</span><br><span class="line">service Greeter &#123;</span><br><span class="line">        rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">        string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">        string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, syntax proto3 indicates the use of version 3 of Protocol Buffers. There are many changes in syntax between v3 and v2, so pay special attention when using it. go_package indicates the storage path of the generated code (package path). The data structure is defined by the message keyword, and the syntax of the data structure is:</p>
<p><code>Data_type Field_name = Tag</code></p>
<p>The message supports nesting, that is, A message references B message as its own field, which represents the aggregation relationship of objects, that is, A object aggregates (references) B object.</p>
<p>For some common data structures, such as common Header, you can define the proto file of the common data structure separately, and then import it for use, for example:</p>
<p><code>import &quot;other_protofile.proto&quot;;</code></p>
<p>Import also supports cascading references, that is, a.proto imports b.proto, b.proto imports c.proto, then a.proto can directly use the message defined in c.proto.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1427014658797027328">https://www.zhihu.com/zvideo/1427014658797027328</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389328756">https://zhuanlan.zhihu.com/p/389328756</a></li>
<li><a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc">http://doc.oschina.net/grpc</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2021-09-30T07:54:13.000Z" title="2021/9/30 下午3:54:13">2021-09-30</time></span><span class="level-item">14 minutes de lectura (Aproximadamente 2082 palabras)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/">gRPC 基础</a></h1><div class="content"><h2 id="gRPC-概览"><a href="#gRPC-概览" class="headerlink" title="gRPC 概览"></a>gRPC 概览</h2><p>gRPC 是由 Google 开发并开源的一种语言中立的 RPC 框架，当前支持 C、Java 和 Go 语言，其中 C 版本支持 C、C++、Node.js、C# 等。在 gRPC 的客户端应用可以像调用本地方法一样直接调用另一台不同的机器上的服务端的方法。</p>
<div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/1.png" style="zoom:100%;">
</div>

<p>简单使用 gRPC 的步骤如下，以 Go 语言为例：</p>
<ol>
<li>写好 proto 文件，用 protoc 生成.pb.go文件</li>
<li>服务端定义 Server，创建 Function 实现接口 -&gt; net.Listen -&gt; grpc.NewServer() -&gt; pb.RegisterXXXServer(server, &amp;Server{}) -&gt; server.Serve(listener)</li>
<li>客户端 grpc.Dial，创建一个 gRPC 连接 -&gt; pb.NewXXXClient(conn)，创建 client -&gt; context.WithTimeout，设置超时时间 -&gt; client.Function，调用接口 -&gt; 如果是流式传输则循环读取数据</li>
</ol>
<h2 id="gRPC-概念详解"><a href="#gRPC-概念详解" class="headerlink" title="gRPC 概念详解"></a>gRPC 概念详解</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/2.png" style="zoom:100%;">
</div>

<h4 id="Unary-RPC"><a href="#Unary-RPC" class="headerlink" title="Unary RPC"></a>Unary RPC</h4><p>客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</p>
<h4 id="Server-streaming-RPC"><a href="#Server-streaming-RPC" class="headerlink" title="Server streaming RPC"></a>Server streaming RPC</h4><p>客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。<br>server 需要向流中发送消息，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n :&#x3D; 0; n &lt; 5; n++ &#123;</span><br><span class="line">    err :&#x3D; server.Send(&amp;pb.StreamResponse&#123;</span><br><span class="line">        StreamValue: req.Data + strconv.Itoa(n),</span><br><span class="line">    &#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client 通过 grpc 调用获得的是一个流传输对象 stream，需要循环接收数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; 判断消息流是否已经结束</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatalf(&quot;ListStr get stream err: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 打印返回值</span><br><span class="line">    log.Println(res.StreamValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client-streaming-RPC"><a href="#Client-streaming-RPC" class="headerlink" title="Client streaming RPC"></a>Client streaming RPC</h4><p>客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。<br>server 使用 stream.Recv() 来循环接收数据流，SendAndClose 表示服务器已经接收消息结束，并发生一个正确的响应给客户端，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for  &#123;</span><br><span class="line">    res,err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; 接收消息结束，发送结果，并关闭</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return stream.SendAndClose(&amp;proto.UploadResponse&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D;nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client 发送数据完毕的时候需要调用 CloseAndRecv，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    img :&#x3D; &amp;proto.Image&#123;FileName:&quot;image&quot;+strconv.Itoa(i),File:&quot;file data&quot;&#125;</span><br><span class="line">    images :&#x3D; &amp;proto.StreamImageList&#123;Image:img&#125;</span><br><span class="line">    err :&#x3D; stream.Send(images)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        ctx.JSON(map[string]string&#123;</span><br><span class="line">            &quot;err&quot;: err.Error(),</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 发送完毕，关闭并获取服务端返回的消息</span><br><span class="line">resp, err :&#x3D; stream.CloseAndRecv()</span><br></pre></td></tr></table></figure>
<h4 id="Bidirectional-streaming-RPC"><a href="#Bidirectional-streaming-RPC" class="headerlink" title="Bidirectional streaming RPC"></a>Bidirectional streaming RPC</h4><p>两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。<br>server 在接收消息的同时发送消息，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamSumData&#123;Number: int32(i)&#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client 需要有一个执行断开连接的标识 CloseSend()，而 server 不需要，因为服务端断开连接是隐式的，我们只需要退出循环即可断开连接，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamRequest&#123;&#125;)</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(&quot;res number: %d&quot;, res.Number)</span><br><span class="line">&#125;</span><br><span class="line">stream.CloseSend()</span><br></pre></td></tr></table></figure>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/3.jpg" style="zoom:100%;">
</div>

<p>Channel 提供一个与特定 gRPC server 的主机和端口建立的连接。Stub 就是在 Channel 的基础上创建而成的，通过 Stub 可以真正的调用 RPC 请求。</p>
<h3 id="基于-CQ-异步"><a href="#基于-CQ-异步" class="headerlink" title="基于 CQ 异步"></a>基于 CQ 异步</h3><div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/4.jpg" style="zoom:100%;">
</div>

<ul>
<li>CQ：异步操作完成的通知队列</li>
<li>StartCall() + Finish()：创建异步任务</li>
<li>CQ.next()：获取完成的异步操作</li>
<li>Tag：标记异步动作的标识</li>
</ul>
<div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/5.jpg" style="zoom:100%;">
</div>

<p>多个线程可以操作同一个CQ。CQ.next() 不仅可以接收到当前处理的请求的完成事件，还可以接收到其他请求的事件。假设第一个请求正在等待它的回复数据传输完成时，一个新的请求到达了，CQ.next() 可以获得新请求产生的事件，并开始并行处理新请求，而不用等待第一个请求的传输完成。</p>
<h3 id="基于回调异步"><a href="#基于回调异步" class="headerlink" title="基于回调异步"></a>基于回调异步</h3><p>在 client 端发送单个请求，在调用 Function 时，除了传入 Request、 Reply 的指针之外，还需要传入一个接收 Status 的回调函数。<br>在 server 端 Function 返回的不是状态，而是 ServerUnaryReactor 指针，通过 CallbackServerContext 获得 reactor，调用 reactor 的 Finish 函数处理返回状态。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><ul>
<li>在 client 端和 server 端之间传输一些自定义的 Metadata。</li>
<li>类似于 HTTP 头，控制调用配置，如压缩、鉴权、超时。</li>
<li>辅助可观测性，如 Trace ID。</li>
</ul>
<h2 id="gRPC-通信协议"><a href="#gRPC-通信协议" class="headerlink" title="gRPC 通信协议"></a>gRPC 通信协议</h2><p>gRPC 通信协议基于标准的 HTTP/2 设计，支持双向流、单 TCP 的多路复用（一个 HTTP 请求无需等待前一个 HTTP 请求返回结果就可以提前发起，多个请求可以共用同一个 HTTP 连接且互不影响）以及消息头压缩和服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</p>
<h2 id="gRPC-序列化机制"><a href="#gRPC-序列化机制" class="headerlink" title="gRPC 序列化机制"></a>gRPC 序列化机制</h2><h3 id="Protocol-Buffers-介绍"><a href="#Protocol-Buffers-介绍" class="headerlink" title="Protocol Buffers 介绍"></a>Protocol Buffers 介绍</h3><p>gRPC 序列化支持 Protocol Buffers。ProtoBuf 是一种轻便高效的数据结构序列化方法，保障了 gRPC 调用的高性能。它的优势在于：</p>
<ul>
<li>ProtoBuf 序列化后的体积要比 json、XML 小很多，序列化/反序列化的速度更快。</li>
<li>支持跨平台、多语言。</li>
<li>使用简单，因为它提供了一套编译工具，可以自动生成序列化、反序列化的样板代码。</li>
</ul>
<p>但是，ProtoBuf 是二进制协议，编码后二进制数据流可读性差，调试麻烦。</p>
<p>ProtoBuf 支持的标量值类型如下：</p>
<div align="center">
<img src="/2021/09/30/gRPC-%E5%9F%BA%E7%A1%80/type.png" style="zoom:100%;">
</div>

<p>ProtoBuf 为什么快？</p>
<ul>
<li>因为每个字段都用 tag+value 这种方式连续存储的，tag 是编号，一般只占用一个字节，value 是字段的值，这样就没有冗余字符。</li>
<li>另外，对于比较小的整数，ProtoBuf 中定义了 Varint 可变整型，可以不用 4 个字节去存。</li>
<li>如果 value 是字符串类型的，从 tag 当中无法了解到 value 具体有多长，ProtoBuf 会在 tag 与 value 之间添加一个 leg 字段去记录字符串的长度，这样就可以不做字符串匹配操作，解析速度非常快。</li>
</ul>
<h3 id="IDL-文件定义"><a href="#IDL-文件定义" class="headerlink" title="IDL 文件定义"></a>IDL 文件定义</h3><p>按照 Protocol Buffers 的语法在 proto 文件中定义 RPC 请求和响应的数据结构，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">option go_package &#x3D; &quot;..&#x2F;helloworld&quot;;</span><br><span class="line">package helloworld;</span><br><span class="line">service Greeter &#123;</span><br><span class="line">        rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">        string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">        string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，syntax proto3 表示使用 v3 版本的 Protocol Buffers，v3 和 v2 版本语法上有较多的变更, 使用的时候需要特别注意。go_package 表示生成代码的存放路径（包路径）。通过 message 关键字来定义数据结构，数据结构的语法为：</p>
<p><code>数据类型 字段名称 = Tag</code></p>
<p>message 是支持嵌套的，即 A message 引用 B message 作为自己的 field，它表示的就是对象聚合关系，即 A 对象聚合（引用）了 B 对象。</p>
<p>对于一些公共的数据结构，例如公共 Header，可以通过单独定义公共数据结构 proto 文件，然后导入的方式使用，示例如下：</p>
<p><code>import &quot;other_protofile.proto&quot;;</code></p>
<p>导入也支持级联引用，即 a.proto 导入了 b.proto,b.proto 导入了 c.proto，则 a.proto 可以直接使用 c.proto 中定义的 message。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1427014658797027328">「直播回放」腾讯工程师分享：gRPC基础概念详解</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389328756">gRPC 基础概念详解</a></li>
<li><a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc">gRPC 官方文档中文版</a></li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/7/">Anterior</a></div><div class="pagination-next"><a href="/page/9/">Siguiente</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><a class="pagination-link is-current" href="/page/8/">8</a></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/14/">14</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/logo.jpg" alt="Iggie Wang (王亮)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Iggie Wang (王亮)</p><p class="is-size-6 is-block">WNLO, HUST</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Entradas</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categorías</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Etiquetas</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hey-kong" target="_blank" rel="noopener">SEGUIR</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Enlaces</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/hey-kong" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="iggiewang@gmail.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Email</span></span><span class="level-right"><span class="level-item tag">iggiewang@gmail.com</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archivos</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Etiquetas</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSAPP/"><span class="tag">CSAPP</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cache/"><span class="tag">Cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Chinese/"><span class="tag">Chinese</span><span class="tag">37</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Edge-computing/"><span class="tag">Edge computing</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/File-System/"><span class="tag">File System</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Key-Value-Store/"><span class="tag">Key-Value Store</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KubeEdge/"><span class="tag">KubeEdge</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Learned-Index/"><span class="tag">Learned Index</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RDMA/"><span class="tag">RDMA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rocksdb/"><span class="tag">Rocksdb</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Iggie Wang&#039;s Cyberspace</a><p class="is-size-7"><span>&copy; 2024 王亮</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Volver arriba" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Este sitio web utiliza cookies para mejorar su experiencia.",
          dismiss: "¡Entendido!",
          allow: "Permitir cookies",
          deny: "Descenso",
          link: "Aprende más",
          policy: "Política de cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Teclea algo..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Teclea algo...","untitled":"(Sin título)","posts":"Entradas","pages":"Páginas","categories":"Categorías","tags":"Etiquetas"});
        });</script></body></html>