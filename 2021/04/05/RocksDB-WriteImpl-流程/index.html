<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>RocksDB WriteImpl 流程 - Iggie Wang&#039;s Cyberspace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Iggie Wang&#039;s Cyberspace"><meta name="msapplication-TileImage" content="/img/dog.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Iggie Wang&#039;s Cyberspace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文对 RocksDB 6.7.3 版本的 WriteImpl 流程进行分析。 概述RocksDB 写入实现主要在 DBImpl::WriteImpl 中，过程主要分为以下三步：  把 WriteBatch 加入队列，多个 WriteBatch 成为一个 WriteGroup 将该 WriteGroup 所有的记录对应的日志写到 WAL 文件中 将该 WriteGroup 所有的 WriteBat"><meta property="og:type" content="blog"><meta property="og:title" content="RocksDB WriteImpl 流程"><meta property="og:url" content="https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="Iggie Wang&#039;s Cyberspace"><meta property="og:description" content="本文对 RocksDB 6.7.3 版本的 WriteImpl 流程进行分析。 概述RocksDB 写入实现主要在 DBImpl::WriteImpl 中，过程主要分为以下三步：  把 WriteBatch 加入队列，多个 WriteBatch 成为一个 WriteGroup 将该 WriteGroup 所有的记录对应的日志写到 WAL 文件中 将该 WriteGroup 所有的 WriteBat"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/write_group.png"><meta property="og:image" content="https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/rocksdb_write.jpg"><meta property="article:published_time" content="2021-04-05T08:33:37.000Z"><meta property="article:author" content="王亮"><meta property="article:tag" content="Rocksdb"><meta property="article:tag" content="Chinese"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/write_group.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/"},"headline":"RocksDB WriteImpl 流程","image":["https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/write_group.png","https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/rocksdb_write.jpg"],"datePublished":"2021-04-05T08:33:37.000Z","author":{"@type":"Person","name":"王亮"},"publisher":{"@type":"Organization","name":"Iggie Wang's Cyberspace","logo":{"@type":"ImageObject","url":null}},"description":"本文对 RocksDB 6.7.3 版本的 WriteImpl 流程进行分析。 概述RocksDB 写入实现主要在 DBImpl::WriteImpl 中，过程主要分为以下三步：  把 WriteBatch 加入队列，多个 WriteBatch 成为一个 WriteGroup 将该 WriteGroup 所有的记录对应的日志写到 WAL 文件中 将该 WriteGroup 所有的 WriteBat"}</script><link rel="canonical" href="https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/"><link rel="icon" href="/img/dog.jpg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Iggie Wang&#039;s Cyberspace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2021/01/16/About-me">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-05T08:33:37.000Z" title="2021/4/5 下午4:33:37">2021-04-05</time>发表</span><span class="level-item">16 分钟读完 (大约2329个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">RocksDB WriteImpl 流程</h1><div class="content"><p><code>本文对 RocksDB 6.7.3 版本的 WriteImpl 流程进行分析。</code></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RocksDB 写入实现主要在 DBImpl::WriteImpl 中，过程主要分为以下三步：</p>
<ul>
<li>把 WriteBatch 加入队列，多个 WriteBatch 成为一个 WriteGroup</li>
<li>将该 WriteGroup 所有的记录对应的日志写到 WAL 文件中</li>
<li>将该 WriteGroup 所有的 WriteBatch 中的一条或者多条记录写到内存中的 Memtable 中</li>
</ul>
<p>其中，每个 WriteBatch 代表一个事务的提交，可以包含多条操作，可以通过调用 WriteBatch::Put/Delete 等操作将对应多条的 key/value 记录加入 WriteBatch 中。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="WriteThread-JoinBatchGroup"><a href="#WriteThread-JoinBatchGroup" class="headerlink" title="WriteThread::JoinBatchGroup"></a>WriteThread::JoinBatchGroup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static WriteThread::AdaptationContext jbg_ctx(<span class="string">&quot;JoinBatchGroup&quot;</span>);</span><br><span class="line">void WriteThread::JoinBatchGroup(Writer* w) &#123;</span><br><span class="line">  TEST_SYNC_POINT_CALLBACK(<span class="string">&quot;WriteThread::JoinBatchGroup:Start&quot;</span>, w);</span><br><span class="line">  assert(w-&gt;batch != nullptr);</span><br><span class="line"></span><br><span class="line">  bool linked_as_leader = LinkOne(w, &amp;newest_writer_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (linked_as_leader) &#123;</span><br><span class="line">    SetState(w, STATE_GROUP_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TEST_SYNC_POINT_CALLBACK(<span class="string">&quot;WriteThread::JoinBatchGroup:Wait&quot;</span>, w);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!linked_as_leader) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Wait util:</span><br><span class="line">     * 1) An existing leader pick us as the new leader when it finishes</span><br><span class="line">     * 2) An existing leader pick us as its follewer and</span><br><span class="line">     * 2.1) finishes the memtable writes on our behalf</span><br><span class="line">     * 2.2) Or tell us to finish the memtable writes <span class="keyword">in</span> pralallel</span><br><span class="line">     * 3) (pipelined write) An existing leader pick us as its follower and</span><br><span class="line">     *    finish book-keeping and WAL write <span class="keyword">for</span> us, enqueue us as pending</span><br><span class="line">     *    memtable writer, and</span><br><span class="line">     * 3.1) we become memtable writer group leader, or</span><br><span class="line">     * 3.2) an existing memtable writer group leader tell us to finish memtable</span><br><span class="line">     *      writes <span class="keyword">in</span> parallel.</span><br><span class="line">     */</span><br><span class="line">    TEST_SYNC_POINT_CALLBACK(<span class="string">&quot;WriteThread::JoinBatchGroup:BeganWaiting&quot;</span>, w);</span><br><span class="line">    AwaitState(w, STATE_GROUP_LEADER | STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                      STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;jbg_ctx);</span><br><span class="line">    TEST_SYNC_POINT_CALLBACK(<span class="string">&quot;WriteThread::JoinBatchGroup:DoneWaiting&quot;</span>, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个事务提交请求都会生成一个 WriteBatch 对象，进入 WriteImpl 函数后各自的线程首先调用 JoinBatchGroup 来加入到队列。该队列主要核心的实现在于 LinkOne 函数，通过 CAS 无锁将多个线程的请求组成请求链表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool WriteThread::LinkOne(Writer* w, std::atomic&lt;Writer*&gt;* newest_writer) &#123;</span><br><span class="line">  assert(newest_writer != nullptr);</span><br><span class="line">  assert(w-&gt;state == STATE_INIT);</span><br><span class="line">  Writer* writers = newest_writer-&gt;load(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    // If write stall <span class="keyword">in</span> effect, and w-&gt;no_slowdown is not <span class="literal">true</span>,</span><br><span class="line">    // block here until stall is cleared. If its <span class="literal">true</span>, <span class="keyword">then</span> <span class="built_in">return</span></span><br><span class="line">    // immediately</span><br><span class="line">    <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (w-&gt;no_slowdown) &#123;</span><br><span class="line">        w-&gt;status = Status::Incomplete(<span class="string">&quot;Write stall&quot;</span>);</span><br><span class="line">        SetState(w, STATE_COMPLETED);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      // Since no_slowdown is <span class="literal">false</span>, <span class="built_in">wait</span> here to be notified of the write</span><br><span class="line">      // stall clearing</span><br><span class="line">      &#123;</span><br><span class="line">        MutexLock lock(&amp;stall_mu_);</span><br><span class="line">        writers = newest_writer-&gt;load(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">          stall_cv_.Wait();</span><br><span class="line">          // Load newest_writers_ again since it may have changed</span><br><span class="line">          writers = newest_writer-&gt;load(std::memory_order_relaxed);</span><br><span class="line">          <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w-&gt;link_older = writers;</span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;compare_exchange_weak(writers, w)) &#123;</span><br><span class="line">      <span class="built_in">return</span> (writers == nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write_group 链表结构如下：</p>
<img src="/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/write_group.png" style="zoom:100%;">

<p>每个 writer 在头部插入，插入时如果发现 link_older 为空，则此 writer 成为 write_group 的 Leader（即链表尾为 Leader）。</p>
<p>在 JoinBatchGroup 中，如果 writer 不是 Leader（在后文把不是 Leader 的 writer 称为 Follower），则会调用 AwaitState 等待被唤醒。</p>
<blockquote>
<p>PS：由于条件锁 Context Switches 代价高，Rocksdb 在 AwaitState 也做了优化，将 pthread_cond_wait 拆成 3 步来做，本文不对该优化进行详细描述。</p>
</blockquote>
<h3 id="WriteImpl-写日志"><a href="#WriteImpl-写日志" class="headerlink" title="WriteImpl 写日志"></a>WriteImpl 写日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_GROUP_LEADER) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  last_batch_group_size_ =</span><br><span class="line">      write_thread_.EnterAsBatchGroupLeader(&amp;w, &amp;wal_write_group);</span><br><span class="line">  const SequenceNumber current_sequence =</span><br><span class="line">      write_thread_.UpdateLastSequence(versions_-&gt;LastSequence()) + 1;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.status.ok() &amp;&amp; !write_options.disableWAL) &#123;</span><br><span class="line">    PERF_TIMER_GUARD(write_wal_time);</span><br><span class="line">    stats-&gt;AddDBStats(InternalStats::kIntStatsWriteDoneBySelf, 1);</span><br><span class="line">    RecordTick(stats_, WRITE_DONE_BY_SELF, 1);</span><br><span class="line">    <span class="keyword">if</span> (wal_write_group.size &gt; 1) &#123;</span><br><span class="line">      stats-&gt;AddDBStats(InternalStats::kIntStatsWriteDoneByOther,</span><br><span class="line">                        wal_write_group.size - 1);</span><br><span class="line">      RecordTick(stats_, WRITE_DONE_BY_OTHER, wal_write_group.size - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    w.status = WriteToWAL(wal_write_group, log_writer, log_used,</span><br><span class="line">                          need_log_sync, need_log_dir_sync, current_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  write_thread_.ExitAsBatchGroupLeader(wal_write_group, w.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成为 Leader 的 writer，负责批量写入 WAL。在写 WAL 前，首先调用 EnterAsBatchGroupLeader 函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">size_t WriteThread::EnterAsBatchGroupLeader(Writer* leader,</span><br><span class="line">                                            WriteGroup* write_group) &#123;</span><br><span class="line">  assert(leader-&gt;link_older == nullptr);</span><br><span class="line">  assert(leader-&gt;batch != nullptr);</span><br><span class="line">  assert(write_group != nullptr);</span><br><span class="line"></span><br><span class="line">  size_t size = WriteBatchInternal::ByteSize(leader-&gt;batch);</span><br><span class="line"></span><br><span class="line">  // Allow the group to grow up to a maximum size, but <span class="keyword">if</span> the</span><br><span class="line">  // original write is small, <span class="built_in">limit</span> the growth so we <span class="keyword">do</span> not slow</span><br><span class="line">  // down the small write too much.</span><br><span class="line">  size_t max_size = max_write_batch_group_size_bytes;</span><br><span class="line">  const uint64_t min_batch_size_bytes = max_write_batch_group_size_bytes / 8;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= min_batch_size_bytes) &#123;</span><br><span class="line">    max_size = size + min_batch_size_bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;last_writer = leader;</span><br><span class="line">  write_group-&gt;size = 1;</span><br><span class="line">  Writer* newest_writer = newest_writer_.load(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  // This is safe regardless of any db mutex status of the <span class="built_in">caller</span>. Previous</span><br><span class="line">  // calls to ExitAsGroupLeader either didn<span class="string">&#x27;t call CreateMissingNewerLinks</span></span><br><span class="line"><span class="string">  // (they emptied the list and then we added ourself as leader) or had to</span></span><br><span class="line"><span class="string">  // explicitly wake us up (the list was non-empty when we added ourself,</span></span><br><span class="line"><span class="string">  // so we have already received our MarkJoined).</span></span><br><span class="line"><span class="string">  CreateMissingNewerLinks(newest_writer);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // Tricky. Iteration start (leader) is exclusive and finish</span></span><br><span class="line"><span class="string">  // (newest_writer) is inclusive. Iteration goes from old to new.</span></span><br><span class="line"><span class="string">  Writer* w = leader;</span></span><br><span class="line"><span class="string">  while (w != newest_writer) &#123;</span></span><br><span class="line"><span class="string">    w = w-&gt;link_newer;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (w-&gt;sync &amp;&amp; !leader-&gt;sync) &#123;</span></span><br><span class="line"><span class="string">      // Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line"><span class="string">      break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (w-&gt;no_slowdown != leader-&gt;no_slowdown) &#123;</span></span><br><span class="line"><span class="string">      // Do not mix writes that are ok with delays with the ones that</span></span><br><span class="line"><span class="string">      // request fail on delays.</span></span><br><span class="line"><span class="string">      break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (w-&gt;disable_wal != leader-&gt;disable_wal) &#123;</span></span><br><span class="line"><span class="string">      // Do not mix writes that enable WAL with the ones whose</span></span><br><span class="line"><span class="string">      // WAL disabled.</span></span><br><span class="line"><span class="string">      break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (w-&gt;batch == nullptr) &#123;</span></span><br><span class="line"><span class="string">      // Do not include those writes with nullptr batch. Those are not writes,</span></span><br><span class="line"><span class="string">      // those are something else. They want to be alone</span></span><br><span class="line"><span class="string">      break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (w-&gt;callback != nullptr &amp;&amp; !w-&gt;callback-&gt;AllowWriteBatching()) &#123;</span></span><br><span class="line"><span class="string">      // dont batch writes that don&#x27;</span>t want to be batched</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto batch_size = WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line">    <span class="keyword">if</span> (size + batch_size &gt; max_size) &#123;</span><br><span class="line">      // Do not make batch too big</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;write_group = write_group;</span><br><span class="line">    size += batch_size;</span><br><span class="line">    write_group-&gt;last_writer = w;</span><br><span class="line">    write_group-&gt;size++;</span><br><span class="line">  &#125;</span><br><span class="line">  TEST_SYNC_POINT_CALLBACK(<span class="string">&quot;WriteThread::EnterAsBatchGroupLeader:End&quot;</span>, w);</span><br><span class="line">  <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，通过 CreateMissingNewerLinks 函数来生成一个双向链表，使得可以从 Leader 开始顺序写。创建完成反向写请求链表之后，则开始计算有多少个写请求可以批量的进行，同时更新 write_group 中的批量写尺寸以及个数等信息，EnterAsBatchGroupLeader 取队列时会把此刻所有的 writer 一次性全取完。</p>
<p>该操作完成之后，则进入写 WAL 的流程了。调用 WriteToWAL，在 MergeBatch 函数中，将根据 write_group 生成一个 merged_batch，该 merged_batch 中记录着应当被写入 WAL 的内容。接着就通过 WriteToWAL 将 merged_batch 写入 WAL 中，这里会根据是否设置了 sync 来决定是否对 WAL 进行落盘操作。</p>
<blockquote>
<p>PS：这里有一个优化点，在生成 merged_batch 的时候，假设该写请求的尺寸为一并且该请求需要写 WAL，则 merged_batch 直接复用了该写请求；反之则会复用一个 tmp_batch_ 对象避免频繁的生成 WriteBatch 对象。在写完 WAL 之后，假设复用了 tmp_batch_，则会清空该对象。</p>
</blockquote>
<p>最后，调用 ExitAsBatchGroupLeader，该函数会决定该 Leader 是否为 STATE_MEMTABLE_WRITER_LEADER（MEMTABLE_WRITER_LEADER数量 &lt;= GROUP_LEADER数量），从而进行写 Memtable 流程。</p>
<h3 id="WriteImpl-写-Memtable"><a href="#WriteImpl-写-Memtable" class="headerlink" title="WriteImpl 写 Memtable"></a>WriteImpl 写 Memtable</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">WriteThread::WriteGroup memtable_write_group;</span><br><span class="line">  <span class="keyword">if</span> (w.state == WriteThread::STATE_MEMTABLE_WRITER_LEADER) &#123;</span><br><span class="line">    PERF_TIMER_GUARD(write_memtable_time);</span><br><span class="line">    assert(w.ShouldWriteToMemtable());</span><br><span class="line">    write_thread_.EnterAsMemTableWriter(&amp;w, &amp;memtable_write_group);</span><br><span class="line">    <span class="keyword">if</span> (memtable_write_group.size &gt; 1 &amp;&amp;</span><br><span class="line">        immutable_db_options_.allow_concurrent_memtable_write) &#123;</span><br><span class="line">      write_thread_.LaunchParallelMemTableWriters(&amp;memtable_write_group);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memtable_write_group.status = WriteBatchInternal::InsertInto(</span><br><span class="line">          memtable_write_group, w.sequence, column_family_memtables_.get(),</span><br><span class="line">          &amp;flush_scheduler_, &amp;trim_history_scheduler_,</span><br><span class="line">          write_options.ignore_missing_column_families, 0 /*log_number*/, this,</span><br><span class="line">          <span class="literal">false</span> /*concurrent_memtable_writes*/, seq_per_batch_, batch_per_txn_);</span><br><span class="line">      versions_-&gt;SetLastSequence(memtable_write_group.last_sequence);</span><br><span class="line">      write_thread_.ExitAsMemTableWriter(&amp;w, memtable_write_group);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.state == WriteThread::STATE_PARALLEL_MEMTABLE_WRITER) &#123;</span><br><span class="line">    assert(w.ShouldWriteToMemtable());</span><br><span class="line">    ColumnFamilyMemTablesImpl column_family_memtables(</span><br><span class="line">        versions_-&gt;GetColumnFamilySet());</span><br><span class="line">    w.status = WriteBatchInternal::InsertInto(</span><br><span class="line">        &amp;w, w.sequence, &amp;column_family_memtables, &amp;flush_scheduler_,</span><br><span class="line">        &amp;trim_history_scheduler_, write_options.ignore_missing_column_families,</span><br><span class="line">        0 /*log_number*/, this, <span class="literal">true</span> /*concurrent_memtable_writes*/,</span><br><span class="line">        <span class="literal">false</span> /*seq_per_batch*/, 0 /*batch_cnt*/, <span class="literal">true</span> /*batch_per_txn*/,</span><br><span class="line">        write_options.memtable_insert_hint_per_batch);</span><br><span class="line">    <span class="keyword">if</span> (write_thread_.CompleteParallelMemTableWriter(&amp;w)) &#123;</span><br><span class="line">      MemTableInsertStatusCheck(w.status);</span><br><span class="line">      versions_-&gt;SetLastSequence(w.write_group-&gt;last_sequence);</span><br><span class="line">      write_thread_.ExitAsMemTableWriter(&amp;w, *w.write_group);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>RocksDB 有一个 allow_concurrent_memtable_write 的配置项，开启后可以并发写 memtable（memtable 能设置并发写，但是 WAL 文件不能，因为 WAL 是一个追加写的文件，多个 writer 必须要串行化），所以接下来分为串行写和并行写来进行分析。</p>
<h4 id="串行写-Memtable"><a href="#串行写-Memtable" class="headerlink" title="串行写 Memtable"></a>串行写 Memtable</h4><p>Leader 调用 InsertInto，对 write_group 进行遍历，将 Leader 和 Follower 的 WriteBatch 写入。之后调用 ExitAsMemTableWriter，把所有 Follower 的状态设置为 STATE_COMPLETED，将它们唤醒，最后再把 Leader 的状态设置为 STATE_COMPLETED。</p>
<h4 id="并行写-Memtable"><a href="#并行写-Memtable" class="headerlink" title="并行写 Memtable"></a>并行写 Memtable</h4><p>调用 LaunchParallelMemTableWriters，遍历 write_group 把 Leader 和 Follower 的状态都设置为 STATE_PARALLEL_MEMTABLE_WRITER，将等待的线程唤醒。最后所有 writer 通过调用 InsertInto 来将 WriteBatch 写入 MemTable 中。writer 完成了 MemTable 的写操作之后，都会调用 CompleteParallelMemTableWriter 函数。该函数会将该 write_group 中运行的任务数减一，当运行中的任务数为零的时候就代表了所有的线程都完成了操作，调用 ExitAsMemTableWriter 把 Leader 的状态设置为 STATE_COMPLETED，反之则会进入等待状态，等待当前其他的写任务完成。</p>
<p>无论是串行写还是并行写，写入 MemTable 完成之后，还有一项工作，就是在取队列时获取 newest_writer_ 和当前时间点处，可能又有很多的写请求产生了，所以批量任务中最后一个完成的线程必须负责重新指定 Leader 给堆积写请求链表的尾部，让其接过 Leader 角色继续进行批量提交。可以看到，串行写和并行写最后都会调用 ExitAsMemTableWriter，正是在该函数中完成了该项工作。</p>
<blockquote>
<p>PS：在高并发场景下，Follow 调用 AwaitState 的平均等待时延差不多是写 WAL 时延的两倍。因为获取 newest_writer_ 后，可能又来了许多写请求，这些写请求先要等待此时的 Leader 完成写流程，还要等待下个 Leader，也就是和这些写请求是同一个 write_group 的 Leader 完成写 WAL 才能被唤醒。</p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><img src="/2021/04/05/RocksDB-WriteImpl-%E6%B5%81%E7%A8%8B/rocksdb_write.jpg" style="zoom:100%;">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/tree/v6.7.3">Rocksdb Source Code 6.7.3</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43479736/article/details/109056437">rocksdb写流程DBImpl::WriteImpl()源代码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161797527">RocksDB写入流程</a></li>
<li><a target="_blank" rel="noopener" href="https://gocode.cc/project/13/article/183">RocksDB 写流程分析</a></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>RocksDB WriteImpl 流程</p><p><a href="https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-流程/">https://www.iggiewang.cn/2021/04/05/RocksDB-WriteImpl-流程/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>王亮</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rocksdb/">Rocksdb</a><a class="link-muted mr-2" rel="tag" href="/tags/Chinese/">Chinese</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/06/WiscKey-Separating-Keys-from-Values-in-SSD-conscious-Storage/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">WiscKey: Separating Keys from Values in SSD-conscious Storage</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/28/Vectorization-vs-Compilation-in-Query-Execution/"><span class="level-item">Vectorization vs. Compilation in Query Execution</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/dog.jpg" alt="Iggie Wang (王亮)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Iggie Wang (王亮)</p><p class="is-size-6 is-block">WNLO, HUST</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hey-kong" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/hey-kong" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="iggiewang@gmail.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Email</span></span><span class="level-right"><span class="level-item tag">iggiewang@gmail.com</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-27T08:33:57.000Z">2022-12-27</time></p><p class="title"><a href="/2022/12/27/eBPF-Introduction/">eBPF Introduction</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-27T08:33:56.000Z">2022-12-27</time></p><p class="title"><a href="/2022/12/27/eBPF-%E6%A6%82%E8%BF%B0/">eBPF 概述</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-05T13:47:42.000Z">2022-06-05</time></p><p class="title"><a href="/2022/06/05/k8s-%E4%B8%89%E7%A7%8D-Service/">k8s 三种 Service</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-20T06:13:10.000Z">2022-05-20</time></p><p class="title"><a href="/2022/05/20/k8s-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84-port/">k8s 集群中的 port</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-15T13:10:43.000Z">2022-03-15</time></p><p class="title"><a href="/2022/03/15/TDengine-%E9%83%A8%E7%BD%B2%E5%B9%B6%E4%B8%8E-Kuiper-%E4%BA%A4%E4%BA%92/">TDengine 部署并与 Kuiper 交互</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSAPP/"><span class="tag">CSAPP</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cache/"><span class="tag">Cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Chinese/"><span class="tag">Chinese</span><span class="tag">37</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Edge-computing/"><span class="tag">Edge computing</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/File-System/"><span class="tag">File System</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Key-Value-Store/"><span class="tag">Key-Value Store</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KubeEdge/"><span class="tag">KubeEdge</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Learned-Index/"><span class="tag">Learned Index</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RDMA/"><span class="tag">RDMA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rocksdb/"><span class="tag">Rocksdb</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">4</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Iggie Wang&#039;s Cyberspace</a><p class="is-size-7"><span>&copy; 2023 王亮</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>