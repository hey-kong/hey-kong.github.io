<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: English - Iggie Wang&#039;s Cyberspace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Iggie Wang&#039;s Cyberspace"><meta name="msapplication-TileImage" content="/img/dog.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Iggie Wang&#039;s Cyberspace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Iggie Wang&#039;s Cyberspace"><meta property="og:url" content="https://www.iggiewang.cn/"><meta property="og:site_name" content="Iggie Wang&#039;s Cyberspace"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.iggiewang.cn/img/og_image.png"><meta property="article:author" content="王亮"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.iggiewang.cn"},"headline":"Iggie Wang's Cyberspace","image":["https://www.iggiewang.cn/img/og_image.png"],"author":{"@type":"Person","name":"王亮"},"publisher":{"@type":"Organization","name":"Iggie Wang's Cyberspace","logo":{"@type":"ImageObject","url":null}},"description":""}</script><link rel="icon" href="/img/dog.jpg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Iggie Wang&#039;s Cyberspace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2021/01/16/About-me">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">English</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-07-21T10:11:31.000Z" title="2023/7/21 下午6:11:31">2023-07-21</time>发表</span><span class="level-item">7 分钟读完 (大约994个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/21/MQTT-Publish-Subscribe/">MQTT Publish/Subscribe</a></h1><div class="content"><h2 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h2><p>Each message must include a topic, through which the broker delivers the message to clients interested in that topic. The specific content of the message is passed in binary form. MQTT is agnostic to the content of the message, and the client can send data in any format, such as binary data, text data, XML data, or JSON data, etc.</p>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><div align="center">
<img src="/2023/07/21/MQTT-Publish-Subscribe/1.png" style="zoom:100%;">
</div>

<p>The topic is a hierarchical structure composed of strings separated by slashes, for example, “home/bedroom/temperature”.</p>
<h4 id="Quality-of-Service"><a href="#Quality-of-Service" class="headerlink" title="Quality of Service"></a>Quality of Service</h4><p>Quality of Service determines the guarantee level for message delivery to the target. Quality of Service is divided into three levels: 0, 1, 2. 0 means the message is delivered at most once, and if it fails, no retries will be made. 1 means the message is delivered at least once, and if the recipient does not explicitly receive it (returns acked), it will continue to retry sending. 2 means the message is delivered exactly once.</p>
<h4 id="Retain-Flag"><a href="#Retain-Flag" class="headerlink" title="Retain Flag"></a>Retain Flag</h4><p>The retain flag determines whether the message is retained as the latest message for this topic. When a new client subscribes to this topic, it will receive the latest retained message for this topic. For each topic, there can be at most one retained message, but there may also be none.</p>
<h4 id="Message-Payload"><a href="#Message-Payload" class="headerlink" title="Message Payload"></a>Message Payload</h4><p>The message payload is the specific content of the message. MQTT is unaware of the content of the message, so users can send any message.</p>
<h4 id="Duplicate-Field"><a href="#Duplicate-Field" class="headerlink" title="Duplicate Field"></a>Duplicate Field</h4><p>When the quality of service of the message is greater than 0, this field is set when the message is retried.</p>
<h3 id="QoS-Levels"><a href="#QoS-Levels" class="headerlink" title="QoS Levels"></a>QoS Levels</h3><p>MQTT supports three Quality of Service (QoS) levels. They are defined as follows:</p>
<ol>
<li><p>QoS 0: At most once delivery<br>This is the lowest level of service. A message is delivered at most once, and it might not be delivered at all if network disruptions occur. The message is sent from the sender (publisher) to the receiver (subscriber) without any confirmation message. There is no retransmission of the message.</p>
</li>
<li><p>QoS 1: At least once delivery<br>In this level of service, a message is assured to be delivered at least once to the receiver. After the sender sends the message, it stores a copy of the message until it receives a PUBACK message from the receiver. If the sender does not receive a PUBACK message within a certain period, it will resend the message.</p>
</li>
<li><p>QoS 2: Exactly once delivery<br>This is the highest level of service, where a message is assured to be delivered exactly once. This is achieved using a four-step handshake process:</p>
<ul>
<li>The sender sends the message and keeps a copy of it. The message is marked as “unconfirmed”.</li>
<li>The receiver responds with a PUBREC message to acknowledge receipt of the message.</li>
<li>The sender receives the PUBREC message, removes the “unconfirmed” mark from the stored message, and responds with a PUBREL message.</li>
<li>Finally, the receiver responds with a PUBCOMP message to confirm that it has processed the PUBREL message. The sender can now safely delete the message from its storage.</li>
</ul>
</li>
</ol>
<p>Each level of service has different trade-offs in terms of network traffic, latency, and complexity. You should choose the appropriate QoS level based on the specific requirements of your application.</p>
<h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><p>If no client subscribes to a topic, any messages published to that topic won’t be received by any client. Clients need to send a subscription request to the broker in order to subscribe to the corresponding topic.</p>
<h3 id="Format-1"><a href="#Format-1" class="headerlink" title="Format"></a>Format</h3><div align="center">
<img src="/2023/07/21/MQTT-Publish-Subscribe/2.png" style="zoom:100%;">
</div>

<h4 id="Packet-Identifier"><a href="#Packet-Identifier" class="headerlink" title="Packet Identifier"></a>Packet Identifier</h4><p>This is a unique identifier for each SUBSCRIBE message. Both the broker and client maintain their own Packet Identifier for each ongoing conversation. The identifier doesn’t need to be globally unique, but it does need to be unique within the scope of the client-broker communication session.</p>
<h4 id="Subscription-List"><a href="#Subscription-List" class="headerlink" title="Subscription List"></a>Subscription List</h4><p>A single SUBSCRIBE message can request multiple topic subscriptions. Each subscription request needs to include the topic to be subscribed to and the desired Quality of Service (QoS) level. The topic string in the SUBSCRIBE packet can include wildcard characters. If the same topic is subscribed to with different QoS levels (i.e., overlapping subscriptions), the broker will deliver messages to the client at the highest QoS level that has been granted.</p>
<h2 id="Subscription-Acknowledgement"><a href="#Subscription-Acknowledgement" class="headerlink" title="Subscription Acknowledgement"></a>Subscription Acknowledgement</h2><p>After the client requests to subscribe to a topic, the broker will respond with a SUBACK.</p>
<h3 id="Format-2"><a href="#Format-2" class="headerlink" title="Format"></a>Format</h3><p>The message includes a Packet Identifier that matches the one in the subscription request, as well as a set of return codes, as shown below:</p>
<div align="center">
<img src="/2023/07/21/MQTT-Publish-Subscribe/3.png" style="zoom:100%;">
</div>


<h4 id="Packet-Identifier-1"><a href="#Packet-Identifier-1" class="headerlink" title="Packet Identifier"></a>Packet Identifier</h4><p>This Packet Identifier should match the one in the corresponding subscription request.</p>
<h4 id="Return-Codes"><a href="#Return-Codes" class="headerlink" title="Return Codes"></a>Return Codes</h4><p>The return codes correspond to the QoS-topic list in the subscription request, confirming the result of each subscription one-to-one. If successful, the corresponding Quality of Service (0/1/2) will be returned. If the subscription fails, the return code will be 0x80 (128 in decimal).</p>
<p>After the client initiates a subscription and receives a successful subscription acknowledgement, this client will be able to normally receive any subsequent messages sent to that topic.</p>
<h2 id="Unsubscribe"><a href="#Unsubscribe" class="headerlink" title="Unsubscribe"></a>Unsubscribe</h2><p>The UNSUBSCRIBE packet is as follows, mainly containing a Packet Identifier and a list of topics to be unsubscribed:</p>
<div align="center">
<img src="/2023/07/21/MQTT-Publish-Subscribe/4.png" style="zoom:100%;">
</div>


<h2 id="Unsubscribe-Acknowledgement"><a href="#Unsubscribe-Acknowledgement" class="headerlink" title="Unsubscribe Acknowledgement"></a>Unsubscribe Acknowledgement</h2><p>The return for an UNSUBSCRIBE request is an UNSUBACK message that only contains a Packet Identifier matching the one in the UNSUBSCRIBE request. An UNSUBACK is sent regardless of whether the topic was previously subscribed to or not.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>MQTT message delivery is implemented through subscribing to specific topics, then publishing messages to those topics.</p>
<p>There’s no need to create and maintain topics before publishing, nor worry about whether there are clients subscribing to specific topics.</p>
<p>The Publish/Subscribe model decouples publishers and subscribers, making it easier to arrange various business scenarios, such as implementing grouping, broadcasting, etc.</p>
<p>However, the Publish/Subscribe model also brings a challenge: if the publisher wishes to be aware of the subscriber’s receipt of a message, this can only be accomplished at the application layer. For example, after a subscriber receives a message, it can publish a confirmation message to the publisher through another topic.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:33:57.000Z" title="2022/12/27 下午4:33:57">2022-12-27</time>发表</span><span class="level-item">6 分钟读完 (大约961个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/eBPF-Introduction/">eBPF Introduction</a></h1><div class="content"><h2 id="What-is-eBPF"><a href="#What-is-eBPF" class="headerlink" title="What is eBPF"></a>What is eBPF</h2><p>eBPF (extended Berkeley Packet Filter) is a virtual machine that runs within the kernel. It allows the extension of kernel functionality in a safe and efficient manner without modifying kernel code or loading additional kernel modules. It is capable of running BPF programs, into which users can inject as needed for execution within the kernel. These programs adhere to a specific instruction set provided by eBPF, must follow certain rules, and only safe programs are allowed to run.</p>
<p>The use of eBPF is on the rise, with an increasing number of eBPF programs being applied. For instance, replacing iptables rules with eBPF allows packets sent from applications to be directly forwarded to the socket of the recipient, effectively handling data packets by shortening the data path and accelerating the data plane.</p>
<h2 id="eBPF-Core-Principles"><a href="#eBPF-Core-Principles" class="headerlink" title="eBPF Core Principles"></a>eBPF Core Principles</h2><p>The architecture diagram of eBPF is as follows:</p>
<div align="center">
<img src="/2022/12/27/eBPF-Introduction/eBPF.png" style="zoom:100%;">
</div>

<p>eBPF is divided into two parts: programs running in user space and programs running in kernel space. The user space program is responsible for loading the BPF bytecode into the eBPF virtual machine in the kernel space, and reading various event information and statistical information returned by the kernel when needed. The BPF virtual machine in the kernel is responsible for executing specific events in the kernel. If data transmission is required, the execution results are sent to the user space through the BPF map or perf-events in the perf buffer. The whole process is as follows:</p>
<ol>
<li><p>The written BPF program will be compiled into BPF bytecode by tools such as Clang, LLVM, etc. (because the BPF program is not a regular ELF program, but bytecode running in a virtual machine). The eBPF program will also include configured event sources, which are actually some hooks that need to be mounted.</p>
</li>
<li><p>The loader will load it into the kernel via the eBPF system call before the program runs. At this time, the verifier will verify the safety of the bytecode, such as verifying that the number of loops must end within a limited time. Once the verification is passed and the mounted event occurs, the logic of the bytecode will be executed in the eBPF virtual machine.</p>
</li>
<li><p>(Optional) Output each event individually, or return statistical data and call stack data through the BPF map, and transmit it to the user space.</p>
</li>
</ol>
<p>eBPF supports a number of major probes, such as static tracing of  socket、tracepoint、USDT, and dynamic tracing of kprobe, uprobe, etc.</p>
<h2 id="Dynamic-Tracing"><a href="#Dynamic-Tracing" class="headerlink" title="Dynamic Tracing"></a>Dynamic Tracing</h2><p>eBPF provides:</p>
<ul>
<li>kprobe/kretprobe for the kernel, where k = kernel</li>
<li>uprobe/uretprobe for applications, where u = userland</li>
</ul>
<p>These are used to detect information at the entry and return (ret) points of functions.</p>
<p>kprobe/kretprobe can probe most kernel functions, but for security reasons, some kernel functions do not allow probe installation, which could lead to failure in tracing.</p>
<p>uprobe/uretprobe are mechanisms to implement dynamic tracing of userland programs. Similar to kprobe/kretprobe, the difference is that the traced functions are in user programs.</p>
<p>Dynamic tracing technology relies on the symbol table of the kernel and applications. For those inline or static functions, probes cannot be installed directly, and they need to be implemented through offset. The nm or strings command can be used to view the symbol table of the application.</p>
<p>The principle of dynamic tracing technology is similar to GDB. When a probe is installed on a certain code segment, the kernel will copy the target position instruction and replace it with an int3 interrupt. The execution flow jumps to the user-specified probe handler, then executes the backed-up instruction. If a ret probe is also specified at this time, it will be executed. Finally, it jumps back to the original instruction sequence.</p>
<p>Next, let’s see how to perform dynamic tracing. First, write a <code>main.go</code> test code:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(sum(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, disable inline optimization and compile the code by executing the <code>go build -gcflags=&quot;-l&quot; ./main.go</code> command. If inline optimization is enabled, it is likely that the Go compiler will eliminate function calls during compilation, so eBPF will not be able to find the probe corresponding to the function.</p>
<p>The next step is to write a bpftrace script <code>main.pt</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN&#123;</span><br><span class="line">    printf(&quot;Hello!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">uprobe:.&#x2F;main:main.sum &#123;printf(&quot;a: %d b: %d\n&quot;, reg(&quot;ax&quot;), reg(&quot;bx&quot;))&#125;</span><br><span class="line">uretprobe:.&#x2F;main:main.sum &#123;printf(&quot;retval: %d\n&quot;, retval)&#125;</span><br><span class="line">END&#123;</span><br><span class="line">    printf(&quot;Bye!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, execute bpftrace to monitor this function call, run the <code>bpftrace main.pt</code> command, then press Ctl+C to exit, and get the following output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">a: 3 b: 3</span><br><span class="line">retval: 6</span><br><span class="line">^CBye!</span><br></pre></td></tr></table></figure>

<h2 id="Static-Tracing"><a href="#Static-Tracing" class="headerlink" title="Static Tracing"></a>Static Tracing</h2><p>“Static” means that the probe’s position and name are hardcoded in the code and are determined at compile time. The implementation principle of static tracing is similar to callbacks: it is executed when activated, and not executed when deactivated, making it more performant than dynamic tracing. Among them:</p>
<ul>
<li>tracepoint is in the kernel</li>
<li>USDT (Userland Statically Defined Tracing) is in the application</li>
</ul>
<p>Static tracing has already included probe parameter information in the kernel and applications, and you can directly access function parameters through <code>args-&gt;parameter_name</code>. You can check the parameter information of tracepoint through <code>bpftrace -lv</code>, for example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -lv tracepoint:syscalls:sys_enter_openat</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># tracepoint:syscalls:sys_enter_openat</span></span><br><span class="line"><span class="comment">#     int __syscall_nr;</span></span><br><span class="line"><span class="comment">#     int dfd;</span></span><br><span class="line"><span class="comment">#     const char * filename;</span></span><br><span class="line"><span class="comment">#     int flags;</span></span><br><span class="line"><span class="comment">#     umode_t mode;</span></span><br></pre></td></tr></table></figure>
<p>Static tracing accesses the filename parameter of sys_enter_openat through <code>args-&gt;filename</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_openat &#123; printf(&quot;%s %s\n&quot;, comm, str(args-&gt;filename)); &#125;&#x27;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Attaching 1 probe...</span></span><br><span class="line"><span class="comment"># uwsgi /proc/self/stat</span></span><br><span class="line"><span class="comment"># uwsgi /proc/self/fd</span></span><br><span class="line"><span class="comment"># uwsgi /proc/self/statm</span></span><br><span class="line"><span class="comment"># uwsgi /proc/loadavg</span></span><br><span class="line"><span class="comment"># uwsgi /proc/self/io</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Here, <code>comm</code> represents the name of the parent process.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-30T07:54:14.000Z" title="2021/9/30 下午3:54:14">2021-09-30</time>发表</span><span class="level-item">9 分钟读完 (大约1398个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/30/gRPC-Introduction/">gRPC Introduction</a></h1><div class="content"><h2 id="gRPC-Overview"><a href="#gRPC-Overview" class="headerlink" title="gRPC Overview"></a>gRPC Overview</h2><p>gRPC is a language-neutral RPC framework developed and open-sourced by Google, currently supporting C, Java, and Go languages. The C version supports languages such as C, C++, Node.js, C#. In gRPC, client applications can directly call methods on a server on a different machine as if they were calling local methods.</p>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/1.png" style="zoom:100%;">
</div>

<p>The simple steps to use gRPC are as follows, taking Go language as an example:</p>
<ol>
<li>Write the proto file and use protoc to generate the .pb.go file.</li>
<li>On the server side, define a Server, create a Function to implement the interface -&gt; net.Listen -&gt; grpc.NewServer() -&gt; pb.RegisterXXXServer(server, &amp;Server{}) -&gt; server.Serve(listener).</li>
<li>On the client side, grpc.Dial to create a gRPC connection -&gt; pb.NewXXXClient(conn) to create a client -&gt; context.WithTimeout to set a timeout -&gt; call the interface with client.Function -&gt; If it is stream transmission, loop to read data.</li>
</ol>
<h2 id="gRPC-Concepts"><a href="#gRPC-Concepts" class="headerlink" title="gRPC Concepts"></a>gRPC Concepts</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/2.png" style="zoom:100%;">
</div>

<h4 id="Unary-RPC"><a href="#Unary-RPC" class="headerlink" title="Unary RPC"></a>Unary RPC</h4><p>The client sends a request to the server and gets a response from the server, just like a normal function call.</p>
<h4 id="Server-streaming-RPC"><a href="#Server-streaming-RPC" class="headerlink" title="Server streaming RPC"></a>Server streaming RPC</h4><p>The client sends a request to the server and can get a data stream to read a series of messages. The client reads from the returned data stream until there are no more messages.<br>The server needs to send messages into the stream, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n :&#x3D; 0; n &lt; 5; n++ &#123;</span><br><span class="line">    err :&#x3D; server.Send(&amp;pb.StreamResponse&#123;</span><br><span class="line">        StreamValue: req.Data + strconv.Itoa(n),</span><br><span class="line">    &#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client gets a stream transmission object ‘stream’ through the grpc call and needs to loop to receive data, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; Determine whether the message stream has ended</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatalf(&quot;ListStr get stream err: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Print the return value</span><br><span class="line">    log.Println(res.StreamValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client-streaming-RPC"><a href="#Client-streaming-RPC" class="headerlink" title="Client streaming RPC"></a>Client streaming RPC</h4><p>The client writes and sends a series of messages to the server using a provided data stream. Once the client finishes writing messages, it waits for the server to read these messages and return a response.</p>
<p>The server uses stream.Recv() to loop to receive the data stream, and SendAndClose indicates that the server has finished receiving messages and sends a correct response to the client, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for  &#123;</span><br><span class="line">    res,err :&#x3D; stream.Recv()</span><br><span class="line">    &#x2F;&#x2F; Message reception ends, send the result, and close</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return stream.SendAndClose(&amp;proto.UploadResponse&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D;nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client needs to call CloseAndRecv when it has finished sending data, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    img :&#x3D; &amp;proto.Image&#123;FileName:&quot;image&quot;+strconv.Itoa(i),File:&quot;file data&quot;&#125;</span><br><span class="line">    images :&#x3D; &amp;proto.StreamImageList&#123;Image:img&#125;</span><br><span class="line">    err :&#x3D; stream.Send(images)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        ctx.JSON(map[string]string&#123;</span><br><span class="line">            &quot;err&quot;: err.Error(),</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Finish sending, close and get the message returned by the server</span><br><span class="line">resp, err :&#x3D; stream.CloseAndRecv()</span><br></pre></td></tr></table></figure>
<h4 id="Bidirectional-streaming-RPC"><a href="#Bidirectional-streaming-RPC" class="headerlink" title="Bidirectional streaming RPC"></a>Bidirectional streaming RPC</h4><p>Both sides can separately send a series of messages via a read-write data stream. These two streams operate independently, so the client and server can read and write in any order they wish, for example: the server can wait for all client messages before writing a response, or it can read a message then write a message, or use other combinations of reading and writing.</p>
<p>The server sends messages while receiving messages, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamSumData&#123;Number: int32(i)&#125;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client needs a flag to disconnect, CloseSend(), but the server doesn’t need it because the server disconnects implicitly. We just need to exit the loop to disconnect, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;</span><br><span class="line">    err &#x3D; stream.Send(&amp;proto.StreamRequest&#123;&#125;)</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    res, err :&#x3D; stream.Recv()</span><br><span class="line">    if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(&quot;res number: %d&quot;, res.Number)</span><br><span class="line">&#125;</span><br><span class="line">stream.CloseSend()</span><br></pre></td></tr></table></figure>
<h3 id="Synchronous"><a href="#Synchronous" class="headerlink" title="Synchronous"></a>Synchronous</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/3.jpg" style="zoom:100%;">
</div>

<p>A Channel provides a connection established with the host and port of a specific gRPC server. A Stub is created based on the Channel, and the RPC request can be actually called through the Stub.</p>
<h3 id="Asynchronous-based-on-CQ"><a href="#Asynchronous-based-on-CQ" class="headerlink" title="Asynchronous based on CQ"></a>Asynchronous based on CQ</h3><div align="center">
<img src="/2021/09/30/gRPC-Introduction/4.jpg" style="zoom:100%;">
</div>

<ul>
<li>CQ: Notification queue for completed asynchronous operations</li>
<li>StartCall() + Finish(): Create asynchronous tasks</li>
<li>CQ.next(): Get completed asynchronous operations</li>
<li>Tag: Identifiers marking asynchronous actions</li>
</ul>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/5.jpg" style="zoom:100%;">
</div>

<p>Multiple threads can operate on the same CQ. CQ.next() can receive not only the completion events of the current request being processed but also the events of other requests. Suppose the first request is waiting for its reply data transmission to complete, and a new request arrives. CQ.next() can get the events generated by the new request and start processing the new request in parallel without waiting for the first request’s transmission to complete.</p>
<h3 id="Asynchronous-based-on-Callback"><a href="#Asynchronous-based-on-Callback" class="headerlink" title="Asynchronous based on Callback"></a>Asynchronous based on Callback</h3><p>On the client side, send a single request, when calling the Function, in addition to passing the pointers of Request and Reply, a callback function receiving Status is also needed.</p>
<p>On the server side, the Function doesn’t return a status, but a ServerUnaryReactor pointer. Get the reactor through CallbackServerContext and call the Finish function of the reactor to handle the return status.</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><ul>
<li>Transfers some custom Metadata between the client and server.</li>
<li>Similar to HTTP headers, it controls call configurations such as compression, authentication, and timeout.</li>
<li>Assists observability, such as Trace ID.</li>
</ul>
<h2 id="gRPC-Communication-Protocol"><a href="#gRPC-Communication-Protocol" class="headerlink" title="gRPC Communication Protocol"></a>gRPC Communication Protocol</h2><p>The gRPC communication protocol is based on standard HTTP/2 design, supports bidirectional streams, multiplexing of single TCP (an HTTP request can be initiated in advance without waiting for the result of the previous HTTP request, and multiple requests can share the same HTTP connection without interfering with each other) and features such as message header compression and server push. These features make gRPC more power-saving and network traffic-saving on mobile devices.</p>
<h2 id="gRPC-Serialization-Mechanism"><a href="#gRPC-Serialization-Mechanism" class="headerlink" title="gRPC Serialization Mechanism"></a>gRPC Serialization Mechanism</h2><h3 id="Introduction-to-Protocol-Buffers"><a href="#Introduction-to-Protocol-Buffers" class="headerlink" title="Introduction to Protocol Buffers"></a>Introduction to Protocol Buffers</h3><p>gRPC serialization supports Protocol Buffers. ProtoBuf is a lightweight and efficient data structure serialization method, ensuring the high performance of gRPC calls. Its advantages include:</p>
<ul>
<li>The volume of ProtoBuf after serialization is much smaller than JSON, XML, and the speed of serialization/deserialization is faster.</li>
<li>Supports cross-platform and multi-language.</li>
<li>Easy to use because it provides a set of compilation tools that can automatically generate serialization and deserialization boilerplate code.</li>
</ul>
<p>However, ProtoBuf is a binary protocol, the readability of the encoded binary data stream is poor, and debugging is troublesome.</p>
<p>The scalar value types supported by ProtoBuf are as follows:</p>
<div align="center">
<img src="/2021/09/30/gRPC-Introduction/type.png" style="zoom:100%;">
</div>

<p>Why is ProtoBuf fast?</p>
<ul>
<li>Because each field is stored continuously in the form of tag+value, the tag is a number, usually only occupying one byte, and the value is the value of the field, so there are no redundant characters.</li>
<li>In addition, for relatively small integers, ProtoBuf defines a Varint variable integer, which does not need to be stored in 4 bytes.</li>
<li>If the value is of string type and the specific length of the value cannot be known from the tag, ProtoBuf will add a leg field between the tag and the value to record the length of the string, so that string matching operations do not need to be performed, and the parsing speed is very fast.</li>
</ul>
<h3 id="Definition-of-IDL-file"><a href="#Definition-of-IDL-file" class="headerlink" title="Definition of IDL file"></a>Definition of IDL file</h3><p>Define the data structure of RPC requests and responses in the proto file according to the syntax of Protocol Buffers, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">option go_package &#x3D; &quot;..&#x2F;helloworld&quot;;</span><br><span class="line">package helloworld;</span><br><span class="line">service Greeter &#123;</span><br><span class="line">        rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">        string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">        string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, syntax proto3 indicates the use of version 3 of Protocol Buffers. There are many changes in syntax between v3 and v2, so pay special attention when using it. go_package indicates the storage path of the generated code (package path). The data structure is defined by the message keyword, and the syntax of the data structure is:</p>
<p><code>Data_type Field_name = Tag</code></p>
<p>The message supports nesting, that is, A message references B message as its own field, which represents the aggregation relationship of objects, that is, A object aggregates (references) B object.</p>
<p>For some common data structures, such as common Header, you can define the proto file of the common data structure separately, and then import it for use, for example:</p>
<p><code>import &quot;other_protofile.proto&quot;;</code></p>
<p>Import also supports cascading references, that is, a.proto imports b.proto, b.proto imports c.proto, then a.proto can directly use the message defined in c.proto.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1427014658797027328">https://www.zhihu.com/zvideo/1427014658797027328</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389328756">https://zhuanlan.zhihu.com/p/389328756</a></li>
<li><a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc">http://doc.oschina.net/grpc</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-28T15:20:52.000Z" title="2021/7/28 下午11:20:52">2021-07-28</time>发表</span><span class="level-item">16 分钟读完 (大约2469个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/28/RDMA-Introduction/">RDMA Introduction</a></h1><div class="content"><p>RDMA (Remote Direct Memory Access) refers to remote direct memory access, which is a method of transferring data in a buffer between two applications over a network.</p>
<ul>
<li>Remote: Data is transferred over a network with remote machines.</li>
<li>Direct: Without the participation of the kernel, all information related to sending transmissions is offloaded to the network card.</li>
<li>Memory: Data is transferred directly between user space virtual memory and the network card without involving the system kernel, with no additional data movement or copying.</li>
<li>Access: Operations such as send, receive, read, write, atomic, etc.</li>
</ul>
<p>RDMA is different from traditional network interfaces because it bypasses the operating system kernel. This gives programs that have implemented RDMA the following characteristics:</p>
<ol>
<li>Absolute minimum latency</li>
<li>Highest throughput</li>
<li>Smallest CPU footprint (that is, areas where CPU involvement is minimized)</li>
</ol>
<h2 id="RDMA-Working-Principles"><a href="#RDMA-Working-Principles" class="headerlink" title="RDMA Working Principles"></a>RDMA Working Principles</h2><div align="center">
<img src="/2021/07/28/RDMA-Introduction/1.png" style="zoom:100%;">
</div>

<p>During the RDMA communication process, for both sending and receiving, and read/write operations, the network card directly transfers data with the memory region that has already been registered for data transfer. This process is fast, does not require CPU participation, and the RDMA network card takes over the work of the CPU, saving resources for other calculations and services.</p>
<p>The working process of RDMA is as follows:</p>
<ol>
<li>When an application performs an RDMA read or write request, it doesn’t perform any data copying. Under the condition that no kernel memory is required, the RDMA request is sent from the application running in user space to the local network card.</li>
<li>The network card reads the content of the buffer and transmits it to the remote network card over the network.</li>
<li>The RDMA information transmitted over the network includes the virtual memory address of the target machine and the data itself. The completion of the request can be completely handled in user space (by polling the RDMA completion queue in user space). RDMA operations enable applications to read data from or write data to the memory of a remote application.</li>
</ol>
<p>Therefore, RDMA can be simply understood as the use of relevant hardware and network technology, allowing the network card to directly read and write the memory of a remote server, ultimately achieving high bandwidth, low latency, and low resource utilization effects. The application does not need to participate in the data transmission process, it only needs to specify the memory read/write address, start the transmission, and wait for the transmission to complete.</p>
<h2 id="RDMA-Data-Transmission"><a href="#RDMA-Data-Transmission" class="headerlink" title="RDMA Data Transmission"></a>RDMA Data Transmission</h2><ol>
<li><p>RDMA Send/Recv<br>This is similar to TCP/IP’s send/recv, but different in that RDMA is based on a message data transfer protocol (not a byte stream transfer protocol), and all packet assemblies are done on RDMA hardware. This means that the bottom 4 layers of the OSI model (Transport Layer, Network Layer, Data Link Layer, Physical Layer) are all completed on RDMA hardware.</p>
</li>
<li><p>RDMA Read<br>The essence of RDMA read operation is a Pull operation, pulling data from remote system memory back to local system memory.</p>
</li>
<li><p>RDMA Write<br>The essence of RDMA write operation is a Push operation, pushing data from local system memory to remote system memory.</p>
</li>
<li><p>RDMA Write with Immediate Data (RDMA write operation supporting immediate data)<br>RDMA write operation supporting immediate data essentially pushes out-of-band data to the remote system, which is similar to out-of-band data in TCP. Optionally, an Immediate 4-byte value can be sent along with the data buffer. This value is presented as part of the receipt notice to the receiver and is not included in the data buffer.</p>
</li>
</ol>
<h2 id="RDMA-Programming-Basics"><a href="#RDMA-Programming-Basics" class="headerlink" title="RDMA Programming Basics"></a>RDMA Programming Basics</h2><p>To use RDMA, we need a network card that supports RDMA communication (i.e., implements the RDMA engine). We call this card an HCA (Host Channel Adapter). Through the PCIe (peripheral component interconnect express) bus, the adapter creates a channel from the RDMA engine to the application’s memory. A good HCA will implement all the logic needed for the executed RDMA protocol on hardware. This includes packetization, reassembly as well as traffic control and reliability assurance. Therefore, from the perspective of the application, it only needs to handle all the buffers.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/2.jpeg" style="zoom:100%;">
</div>

<p>As shown in the above figure, in RDMA programming, we use the command channel to call the kernel mode driver to establish the data channel, which allows us to completely bypass the kernel when moving data. Once this data channel is established, we can directly read and write the data buffer. The API to establish a data channel is an API called verbs. The verbs API is maintained by a Linux open-source project called the Open Fabrics Enterprise Distribution (OFED).</p>
<h3 id="Key-Concepts"><a href="#Key-Concepts" class="headerlink" title="Key Concepts"></a>Key Concepts</h3><p>RDMA operation starts with memory operation. When you operate on memory, you are telling the kernel that this segment of memory is occupied by your application. So, you tell the HCA to address on this segment of memory and prepare to open a channel from the HCA card to this memory. We call this action registering a memory region MR (Memory Region). When registering, you can set the read and write permissions of the memory region (including local write, remote read, remote write, atomic, and bind). The Verbs API ibv_reg_mr can be used to register MR, which returns the remote and local keys of MR. The local key is used for the local HCA to access local memory. The remote key is provided to the remote HCA to access local memory. Once the MR is registered, we can use this memory for any RDMA operation. In the figure below, we can see the registered memory region (MR) and the buffer located within the memory region used by the communication queue.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/3.jpeg" style="zoom:100%;">
</div>

<p>RDMA communication is based on a collection of three queues SQ (Send Queue), RQ (Receive Queue), and CQ (Completion Queue). The Send Queue (SQ) and Receive Queue (RQ) are responsible for scheduling work, they are always created in pairs, called Queue Pair (QP). The Completion Queue (CQ) is used to send notifications when instructions placed on the work queue are completed.</p>
<p>When a user places instructions on the work queue, it means telling the HCA which buffers need to be sent or used to receive data. These instructions are small structures, called Work Requests (WR) or Work Queue Elements (WQE). A WQE mainly contains a pointer to a buffer. A WQE placed in the Send Queue (SQ) contains a pointer to a message to be sent; a pointer in a WQE placed in the Receive Queue points to a buffer, which is used to store the message to be received.</p>
<p>RDMA is an asynchronous transmission mechanism. Therefore, we can place multiple send or receive WQEs in the work queue at once. The HCA will process these WQEs as quickly as possible in order. When a WQE is processed, the data is moved. Once the transmission is completed, the HCA creates a Completion Queue Element (CQE) with a successful status and places it in the Completion Queue (CQ). If the transmission fails for some reason, the HCA also creates a CQE with a failed status and places it in the CQ.</p>
<h3 id="Example-Send-Recv"><a href="#Example-Send-Recv" class="headerlink" title="Example (Send/Recv)"></a>Example (Send/Recv)</h3><p>Step 1: Both system A and B create their own QPs and CQs, and register the corresponding memory regions (MR) for the upcoming RDMA transfer. System A identifies a buffer, the data of which will be moved to system B. System B allocates an empty buffer to store data sent from system A.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/4.jpeg" style="zoom:100%;">
</div>

<p>Step 2: System B creates a WQE and places it in its Receive Queue (RQ). This WQE contains a pointer, which points to a memory buffer to store received data. System A also creates a WQE and places it in its Send Queue (SQ), the pointer in the WQE points to a memory buffer, the data of which will be transmitted.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/5.jpeg" style="zoom:100%;">
</div>

<p>Step 3: The HCA on system A always works on hardware, checking if there are any WQEs in the send queue. The HCA will consume the WQE from system A and send the data in the memory region to system B as a data stream. When the data stream starts to arrive at system B, the HCA on system B consumes the WQE from system B and puts the data into the designated buffer. The data stream transmitted on the high-speed channel completely bypasses the operating system kernel.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/6.jpeg" style="zoom:100%;">
</div>

<p>Note: The arrows on the WQE represent pointers (addresses) to user space memory. In receive/send mode, both parties need to prepare their own WQEs (WorkQueue) in advance, and the HCA will write (CQ) after completion.</p>
<p>Step 4: When the data movement is completed, the HCA creates a CQE. This CQE is placed in the Completion Queue (CQ), indicating that data transmission has been completed. The HCA creates a CQE for each consumed WQE. Therefore, placing a CQE in the completion queue of system A means that the send operation of the corresponding WQE has been completed. Similarly, a CQE will also be placed in the completion queue of system B, indicating that the receive operation of the corresponding WQE has been completed. If an error occurs, the HCA will still create a CQE. The CQE contains a field to record the transmission status.</p>
<div align="center">
<img src="/2021/07/28/RDMA-Introduction/7.jpeg" style="zoom:100%;">
</div>

<p>In IB or RoCE, the total time to transmit data in a small buffer is about 1.3µs. By simultaneously creating a lot of WQEs, data stored in millions of buffers can be transmitted in one second.</p>
<h3 id="RDMA-Operation-Details"><a href="#RDMA-Operation-Details" class="headerlink" title="RDMA Operation Details"></a>RDMA Operation Details</h3><p>In RDMA transfer, Send/Recv is a bilateral operation, i.e., it requires the participation of both communicating parties, and Recv must be executed before Send so that the other party can send data. Of course, if the other party does not need to send data, the Recv operation can be omitted. Therefore, this process is similar to traditional communication. The difference lies in RDMA’s zero-copy network technology and kernel bypass, which results in low latency and is often used for transmitting short control messages.</p>
<p>Write/Read is a unilateral operation, as the name suggests, read/write operations are executed by one party. In actual communication, Write/Read operations are executed by the client, and the server does not need to perform any operations. In RDMA Write operation, the client pushes data directly from the local buffer into the continuous memory block in the remote QP’s virtual space (physical memory may not be continuous). Therefore, it needs to know the destination address (remote addr) and access rights (remote key). In RDMA Read operation, the client directly fetches data from the continuous memory block in the remote QP’s virtual space and pulls it into the local destination buffer. Therefore, it needs the memory address and access rights of the remote QP. Unilateral operations are often used for bulk data transfer.</p>
<p>It can be seen that in the unilateral operation process, the client needs to know the remote addr and remote key of the remote QP. These two pieces of information can be exchanged through Send/Recv operations.</p>
<h4 id="RDMA-Unilateral-Operation-READ-WRITE"><a href="#RDMA-Unilateral-Operation-READ-WRITE" class="headerlink" title="RDMA Unilateral Operation (READ/WRITE)"></a>RDMA Unilateral Operation (READ/WRITE)</h4><p>READ and WRITE are unilateral operations, where only the source and destination addresses of the information need to be clearly known at the local end. The remote application does not need to be aware of this communication, and the reading or writing of data is completed through RDMA between the network card and the application Buffer, and then returned to the local end by the remote network card as encapsulated messages.</p>
<p>For unilateral operations, take storage in the context of a storage network as an example, the READ process is as follows:</p>
<ol>
<li>First, A and B establish a connection, and the QP has been created and initialized.</li>
<li>The data is archived at B’s buffer address VB. Note that VB should be pre-registered with B’s network card (and it is a memory region) and get the returned remote key, which is equivalent to the permission to operate this buffer with RDMA.</li>
<li>B encapsulates the data address VB and key into a dedicated message and sends it to A, which is equivalent to B handing over the operation right of the data buffer to A. At the same time, B registers a WR in its WQ to receive the status returned by A for data transmission.</li>
<li>After A receives the data VB and remote key sent by B, the network card will package them together with its own storage address VA into an RDMA READ request and send this message request to B. In this process, both A and B can store B’s data to A’s VA virtual address without any software participation.</li>
<li>After A completes the storage, it will return the status information of the entire data transfer to B.</li>
</ol>
<p>The WRITE process is similar to READ. The unilateral operation transmission method is the biggest difference between RDMA and traditional network transmission. It only needs to provide direct access to the remote virtual address, and does not require remote applications to participate, which is suitable for bulk data transmission.</p>
<h4 id="RDMA-Bilateral-Operation-SEND-RECEIVE"><a href="#RDMA-Bilateral-Operation-SEND-RECEIVE" class="headerlink" title="RDMA Bilateral Operation (SEND/RECEIVE)"></a>RDMA Bilateral Operation (SEND/RECEIVE)</h4><p>SEND/RECEIVE in RDMA is a bilateral operation, that is, the remote application must be aware of and participate in the completion of the transmission and reception. In practice, SEND/RECEIVE is often used for connection control messages, while data messages are mostly completed through READ/WRITE.</p>
<p>Taking the bilateral operation as an example, the process of host A sending data to host B (hereinafter referred to as A and B) is as follows:</p>
<ol>
<li>First of all, A and B must create and initialize their own QP and CQ.</li>
<li>A and B register WQE in their own WQ. For A, WQ = SQ, WQE describes a data that is about to be sent; for B, WQ = RQ, WQE describes a Buffer for storing data.</li>
<li>A’s network card asynchronously schedules to A’s WQE, parses that this is a SEND message, and sends data directly to B from the buffer. When the data stream arrives at B’s network card, B’s WQE is consumed, and the data is directly stored in the storage location pointed to by the WQE.</li>
<li>After A and B communication is completed, a completion message CQE will be generated in A’s CQ indicating that the sending is completed. At the same time, a completion message will be generated in B’s CQ indicating that the reception is completed. The processing of each WQE in WQ will generate a CQE.</li>
</ol>
<p>Bilateral operation is similar to the underlying Buffer Pool of traditional networks, and there is no difference in the participation process of the sender and receiver. The difference lies in zero-copy and kernel bypass. In fact, for RDMA, this is a complex message transmission mode, often used for transmitting short control messages.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/49103d9cf895fa40a5cd397f8">https://xie.infoq.cn/article/49103d9cf895fa40a5cd397f8</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55142557">https://zhuanlan.zhihu.com/p/55142557</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55142547">https://zhuanlan.zhihu.com/p/55142547</a></li>
</ol>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/dog.jpg" alt="Iggie Wang (王亮)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Iggie Wang (王亮)</p><p class="is-size-6 is-block">WNLO, HUST</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hey-kong" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/hey-kong" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="iggiewang@gmail.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Email</span></span><span class="level-right"><span class="level-item tag">iggiewang@gmail.com</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-21T10:11:31.000Z">2023-07-21</time></p><p class="title"><a href="/2023/07/21/MQTT-Publish-Subscribe/">MQTT Publish/Subscribe</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-27T08:33:57.000Z">2022-12-27</time></p><p class="title"><a href="/2022/12/27/eBPF-Introduction/">eBPF Introduction</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-27T08:33:56.000Z">2022-12-27</time></p><p class="title"><a href="/2022/12/27/eBPF-%E6%A6%82%E8%BF%B0/">eBPF 概述</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-05T13:47:42.000Z">2022-06-05</time></p><p class="title"><a href="/2022/06/05/k8s-%E4%B8%89%E7%A7%8D-Service/">k8s 三种 Service</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-20T06:13:10.000Z">2022-05-20</time></p><p class="title"><a href="/2022/05/20/k8s-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84-port/">k8s 集群中的 port</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSAPP/"><span class="tag">CSAPP</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cache/"><span class="tag">Cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Chinese/"><span class="tag">Chinese</span><span class="tag">37</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Edge-computing/"><span class="tag">Edge computing</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/File-System/"><span class="tag">File System</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Key-Value-Store/"><span class="tag">Key-Value Store</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KubeEdge/"><span class="tag">KubeEdge</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Learned-Index/"><span class="tag">Learned Index</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RDMA/"><span class="tag">RDMA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rocksdb/"><span class="tag">Rocksdb</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">4</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Iggie Wang&#039;s Cyberspace</a><p class="is-size-7"><span>&copy; 2023 王亮</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>